/* tslint:disable */
/* eslint-disable */
/**
 * Stable Horde
 * The API documentation for the Stable Horde
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActiveModel
 */
export interface ActiveModel {
    /**
     * The Name of a model available by workers in this horde.
     * @type {string}
     * @memberof ActiveModel
     */
    'name'?: string;
    /**
     * How many of workers in this horde are running this model.
     * @type {number}
     * @memberof ActiveModel
     */
    'count'?: number;
    /**
     * The average speed of generation for this model
     * @type {number}
     * @memberof ActiveModel
     */
    'performance'?: number;
    /**
     * The amount waiting to be generated by this model
     * @type {number}
     * @memberof ActiveModel
     */
    'queued'?: number;
    /**
     * Estimated time in seconds for this model\'s queue to be cleared
     * @type {number}
     * @memberof ActiveModel
     */
    'eta'?: number;
}
/**
 * 
 * @export
 * @interface ActiveModelAllOf
 */
export interface ActiveModelAllOf {
    /**
     * The average speed of generation for this model
     * @type {number}
     * @memberof ActiveModelAllOf
     */
    'performance'?: number;
    /**
     * The amount waiting to be generated by this model
     * @type {number}
     * @memberof ActiveModelAllOf
     */
    'queued'?: number;
    /**
     * Estimated time in seconds for this model\'s queue to be cleared
     * @type {number}
     * @memberof ActiveModelAllOf
     */
    'eta'?: number;
}
/**
 * 
 * @export
 * @interface ActiveModelLite
 */
export interface ActiveModelLite {
    /**
     * The Name of a model available by workers in this horde.
     * @type {string}
     * @memberof ActiveModelLite
     */
    'name'?: string;
    /**
     * How many of workers in this horde are running this model.
     * @type {number}
     * @memberof ActiveModelLite
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface ContributionsDetails
 */
export interface ContributionsDetails {
    /**
     * How many images this user has generated
     * @type {number}
     * @memberof ContributionsDetails
     */
    'fulfillments'?: number;
}
/**
 * 
 * @export
 * @interface ContributionsDetailsStable
 */
export interface ContributionsDetailsStable {
    /**
     * How many images this user has generated
     * @type {number}
     * @memberof ContributionsDetailsStable
     */
    'fulfillments'?: number;
    /**
     * How many megapixelsteps this user has generated
     * @type {number}
     * @memberof ContributionsDetailsStable
     */
    'megapixelsteps'?: number;
}
/**
 * 
 * @export
 * @interface ContributionsDetailsStableAllOf
 */
export interface ContributionsDetailsStableAllOf {
    /**
     * How many megapixelsteps this user has generated
     * @type {number}
     * @memberof ContributionsDetailsStableAllOf
     */
    'megapixelsteps'?: number;
}
/**
 * 
 * @export
 * @interface CreateTeamInput
 */
export interface CreateTeamInput {
    /**
     * The name of the team. No profanity allowed!
     * @type {string}
     * @memberof CreateTeamInput
     */
    'name': string;
    /**
     * Extra information or comments about this team.
     * @type {string}
     * @memberof CreateTeamInput
     */
    'info'?: string;
}
/**
 * 
 * @export
 * @interface DeleteTimeoutIPInput
 */
export interface DeleteTimeoutIPInput {
    /**
     * The IP address to remove from timeout
     * @type {string}
     * @memberof DeleteTimeoutIPInput
     */
    'ipaddr': string;
}
/**
 * 
 * @export
 * @interface DeletedTeam
 */
export interface DeletedTeam {
    /**
     * The ID of the deleted team
     * @type {string}
     * @memberof DeletedTeam
     */
    'deleted_id'?: string;
    /**
     * The Name of the deleted team
     * @type {string}
     * @memberof DeletedTeam
     */
    'deleted_name'?: string;
}
/**
 * 
 * @export
 * @interface DeletedWorker
 */
export interface DeletedWorker {
    /**
     * The ID of the deleted worker
     * @type {string}
     * @memberof DeletedWorker
     */
    'deleted_id'?: string;
    /**
     * The Name of the deleted worker
     * @type {string}
     * @memberof DeletedWorker
     */
    'deleted_name'?: string;
}
/**
 * 
 * @export
 * @interface Generation
 */
export interface Generation {
    /**
     * The UUID of the worker which generated this image
     * @type {string}
     * @memberof Generation
     */
    'worker_id'?: string;
    /**
     * The name of the worker which generated this image
     * @type {string}
     * @memberof Generation
     */
    'worker_name'?: string;
    /**
     * The model which generated this image
     * @type {string}
     * @memberof Generation
     */
    'model'?: string;
}
/**
 * 
 * @export
 * @interface GenerationInput
 */
export interface GenerationInput {
    /**
     * The prompt which will be sent to Stable Diffusion to generate an image
     * @type {string}
     * @memberof GenerationInput
     */
    'prompt': string;
    /**
     * 
     * @type {ModelGenerationInputStable}
     * @memberof GenerationInput
     */
    'params'?: ModelGenerationInputStable;
    /**
     * Set to true if this request is NSFW. This will skip workers which censor images.
     * @type {boolean}
     * @memberof GenerationInput
     */
    'nsfw'?: boolean;
    /**
     * When true, only trusted workers will serve this request. When False, Evaluating workers will also be used which can increase speed but adds more risk!
     * @type {boolean}
     * @memberof GenerationInput
     */
    'trusted_workers'?: boolean;
    /**
     * If the request is SFW, and the worker accidentaly generates NSFW, it will send back a censored image.
     * @type {boolean}
     * @memberof GenerationInput
     */
    'censor_nsfw'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof GenerationInput
     */
    'workers'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GenerationInput
     */
    'models'?: Array<string>;
    /**
     * The Base64-encoded webp to use for img2img
     * @type {string}
     * @memberof GenerationInput
     */
    'source_image'?: string;
    /**
     * If source_image is provided, specifies how to process it.
     * @type {string}
     * @memberof GenerationInput
     */
    'source_processing'?: GenerationInputSourceProcessingEnum;
    /**
     * If source_processing is set to \'inpainting\' or \'outpainting\', this parameter can be optionally provided as the  Base64-encoded webp mask of the areas to inpaint. If this arg is not passed, the inpainting/outpainting mask has to be embedded as alpha channel
     * @type {string}
     * @memberof GenerationInput
     */
    'source_mask'?: string;
    /**
     * If True, the image will be sent via cloudflare r2 download link
     * @type {boolean}
     * @memberof GenerationInput
     */
    'r2'?: boolean;
}

export const GenerationInputSourceProcessingEnum = {
    Img2img: 'img2img',
    Inpainting: 'inpainting',
    Outpainting: 'outpainting'
} as const;

export type GenerationInputSourceProcessingEnum = typeof GenerationInputSourceProcessingEnum[keyof typeof GenerationInputSourceProcessingEnum];

/**
 * 
 * @export
 * @interface GenerationPayload
 */
export interface GenerationPayload {
    /**
     * 
     * @type {ModelPayloadStable}
     * @memberof GenerationPayload
     */
    'payload'?: ModelPayloadStable;
    /**
     * The UUID for this image generation
     * @type {string}
     * @memberof GenerationPayload
     */
    'id'?: string;
    /**
     * 
     * @type {NoValidRequestFoundStable}
     * @memberof GenerationPayload
     */
    'skipped'?: NoValidRequestFoundStable;
    /**
     * Which of the available models to use for this request
     * @type {string}
     * @memberof GenerationPayload
     */
    'model'?: string;
    /**
     * The Base64-encoded webp to use for img2img
     * @type {string}
     * @memberof GenerationPayload
     */
    'source_image'?: string;
    /**
     * If source_image is provided, specifies how to process it.
     * @type {string}
     * @memberof GenerationPayload
     */
    'source_processing'?: GenerationPayloadSourceProcessingEnum;
    /**
     * If img_processing is set to \'inpainting\' or \'outpainting\', this parameter can be optionally provided as the mask of the areas to inpaint. If this arg is not passed, the inpainting/outpainting mask has to be embedded as alpha channel
     * @type {string}
     * @memberof GenerationPayload
     */
    'source_mask'?: string;
    /**
     * The r2 upload link to use to upload this image
     * @type {string}
     * @memberof GenerationPayload
     */
    'r2_upload'?: string;
}

export const GenerationPayloadSourceProcessingEnum = {
    Img2img: 'img2img',
    Inpainting: 'inpainting',
    Outpainting: 'outpainting'
} as const;

export type GenerationPayloadSourceProcessingEnum = typeof GenerationPayloadSourceProcessingEnum[keyof typeof GenerationPayloadSourceProcessingEnum];

/**
 * 
 * @export
 * @interface GenerationStable
 */
export interface GenerationStable {
    /**
     * The UUID of the worker which generated this image
     * @type {string}
     * @memberof GenerationStable
     */
    'worker_id'?: string;
    /**
     * The name of the worker which generated this image
     * @type {string}
     * @memberof GenerationStable
     */
    'worker_name'?: string;
    /**
     * The model which generated this image
     * @type {string}
     * @memberof GenerationStable
     */
    'model'?: string;
    /**
     * The generated image as a Base64-encoded .webp file
     * @type {string}
     * @memberof GenerationStable
     */
    'img'?: string;
    /**
     * The seed which generated this image
     * @type {string}
     * @memberof GenerationStable
     */
    'seed'?: string;
}
/**
 * 
 * @export
 * @interface GenerationStableAllOf
 */
export interface GenerationStableAllOf {
    /**
     * The generated image as a Base64-encoded .webp file
     * @type {string}
     * @memberof GenerationStableAllOf
     */
    'img'?: string;
    /**
     * The seed which generated this image
     * @type {string}
     * @memberof GenerationStableAllOf
     */
    'seed'?: string;
}
/**
 * 
 * @export
 * @interface GenerationSubmitted
 */
export interface GenerationSubmitted {
    /**
     * The amount of kudos gained for submitting this request
     * @type {number}
     * @memberof GenerationSubmitted
     */
    'reward'?: number;
}
/**
 * 
 * @export
 * @interface HordeModes
 */
export interface HordeModes {
    /**
     * When True, this Horde will not accept new requests for image generation, but will finish processing the ones currently in the queue.
     * @type {boolean}
     * @memberof HordeModes
     */
    'maintenance_mode'?: boolean;
    /**
     * When True, this Horde will not only accept worker explicitly invited to join.
     * @type {boolean}
     * @memberof HordeModes
     */
    'invite_only_mode'?: boolean;
    /**
     * When True, this Horde will not always provide full information in order to throw off attackers.
     * @type {boolean}
     * @memberof HordeModes
     */
    'raid_mode'?: boolean;
}
/**
 * 
 * @export
 * @interface HordePerformance
 */
export interface HordePerformance {
    /**
     * The amount of waiting and processing requests currently in this Horde
     * @type {number}
     * @memberof HordePerformance
     */
    'queued_requests'?: number;
    /**
     * How many workers are actively processing prompt generations in this Horde in the past 5 minutes
     * @type {number}
     * @memberof HordePerformance
     */
    'worker_count'?: number;
    /**
     * How many worker threads are actively processing prompt generations in this Horde in the past 5 minutes
     * @type {number}
     * @memberof HordePerformance
     */
    'thread_count'?: number;
}
/**
 * 
 * @export
 * @interface HordePerformanceStable
 */
export interface HordePerformanceStable {
    /**
     * The amount of waiting and processing requests currently in this Horde
     * @type {number}
     * @memberof HordePerformanceStable
     */
    'queued_requests'?: number;
    /**
     * How many workers are actively processing prompt generations in this Horde in the past 5 minutes
     * @type {number}
     * @memberof HordePerformanceStable
     */
    'worker_count'?: number;
    /**
     * How many worker threads are actively processing prompt generations in this Horde in the past 5 minutes
     * @type {number}
     * @memberof HordePerformanceStable
     */
    'thread_count'?: number;
    /**
     * The amount of megapixelsteps in waiting and processing requests currently in this Horde
     * @type {number}
     * @memberof HordePerformanceStable
     */
    'queued_megapixelsteps'?: number;
    /**
     * How many megapixelsteps this Horde generated in the last minute
     * @type {number}
     * @memberof HordePerformanceStable
     */
    'past_minute_megapixelsteps'?: number;
    /**
     * The amount of image interrogations waiting and processing currently in this Horde
     * @type {number}
     * @memberof HordePerformanceStable
     */
    'queued_forms'?: number;
    /**
     * How many workers are actively processing image interrogations in this Horde in the past 5 minutes
     * @type {number}
     * @memberof HordePerformanceStable
     */
    'interrogator_count'?: number;
    /**
     * How many worker threads are actively processing image interrogation in this Horde in the past 5 minutes
     * @type {number}
     * @memberof HordePerformanceStable
     */
    'interrogator_thread_count'?: number;
}
/**
 * 
 * @export
 * @interface HordePerformanceStableAllOf
 */
export interface HordePerformanceStableAllOf {
    /**
     * The amount of megapixelsteps in waiting and processing requests currently in this Horde
     * @type {number}
     * @memberof HordePerformanceStableAllOf
     */
    'queued_megapixelsteps'?: number;
    /**
     * How many megapixelsteps this Horde generated in the last minute
     * @type {number}
     * @memberof HordePerformanceStableAllOf
     */
    'past_minute_megapixelsteps'?: number;
    /**
     * The amount of image interrogations waiting and processing currently in this Horde
     * @type {number}
     * @memberof HordePerformanceStableAllOf
     */
    'queued_forms'?: number;
    /**
     * How many workers are actively processing image interrogations in this Horde in the past 5 minutes
     * @type {number}
     * @memberof HordePerformanceStableAllOf
     */
    'interrogator_count'?: number;
    /**
     * How many worker threads are actively processing image interrogation in this Horde in the past 5 minutes
     * @type {number}
     * @memberof HordePerformanceStableAllOf
     */
    'interrogator_thread_count'?: number;
}
/**
 * 
 * @export
 * @interface InterrogationFormResult
 */
export interface InterrogationFormResult {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof InterrogationFormResult
     */
    '*'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface InterrogationFormStatus
 */
export interface InterrogationFormStatus {
    /**
     * The name of this interrogation form
     * @type {string}
     * @memberof InterrogationFormStatus
     */
    'form'?: string;
    /**
     * The overall status of this interrogation
     * @type {string}
     * @memberof InterrogationFormStatus
     */
    'state'?: string;
    /**
     * 
     * @type {InterrogationFormResult}
     * @memberof InterrogationFormStatus
     */
    'result'?: InterrogationFormResult;
}
/**
 * 
 * @export
 * @interface InterrogationPopFormPayload
 */
export interface InterrogationPopFormPayload {
    /**
     * The UUID of the interrogation form. Use this to post the results in the future
     * @type {string}
     * @memberof InterrogationPopFormPayload
     */
    'id'?: string;
    /**
     * The name of this interrogation form
     * @type {string}
     * @memberof InterrogationPopFormPayload
     */
    'form'?: InterrogationPopFormPayloadFormEnum;
    /**
     * 
     * @type {ModelInterrogationFormPayloadStable}
     * @memberof InterrogationPopFormPayload
     */
    'payload'?: ModelInterrogationFormPayloadStable;
    /**
     * The URL From which the source image can be downloaded
     * @type {string}
     * @memberof InterrogationPopFormPayload
     */
    'source_image'?: string;
}

export const InterrogationPopFormPayloadFormEnum = {
    Caption: 'caption',
    Interrogation: 'interrogation',
    Nsfw: 'nsfw'
} as const;

export type InterrogationPopFormPayloadFormEnum = typeof InterrogationPopFormPayloadFormEnum[keyof typeof InterrogationPopFormPayloadFormEnum];

/**
 * 
 * @export
 * @interface InterrogationPopInput
 */
export interface InterrogationPopInput {
    /**
     * The Name of the Worker
     * @type {string}
     * @memberof InterrogationPopInput
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InterrogationPopInput
     */
    'priority_usernames'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InterrogationPopInput
     */
    'forms'?: Array<InterrogationPopInputFormsEnum>;
    /**
     * The amount of forms to pop at the same time
     * @type {number}
     * @memberof InterrogationPopInput
     */
    'amount'?: number;
    /**
     * The version of the bridge used by this worker
     * @type {number}
     * @memberof InterrogationPopInput
     */
    'bridge_version'?: number;
    /**
     * How many threads this worker is running. This is used to accurately the current power available in the horde
     * @type {number}
     * @memberof InterrogationPopInput
     */
    'threads'?: number;
}

export const InterrogationPopInputFormsEnum = {
    Caption: 'caption',
    Interrogation: 'interrogation',
    Nsfw: 'nsfw'
} as const;

export type InterrogationPopInputFormsEnum = typeof InterrogationPopInputFormsEnum[keyof typeof InterrogationPopInputFormsEnum];

/**
 * 
 * @export
 * @interface InterrogationPopPayload
 */
export interface InterrogationPopPayload {
    /**
     * 
     * @type {Array<InterrogationPopFormPayload>}
     * @memberof InterrogationPopPayload
     */
    'forms'?: Array<InterrogationPopFormPayload>;
    /**
     * 
     * @type {NoValidInterrogationsFound}
     * @memberof InterrogationPopPayload
     */
    'skipped'?: NoValidInterrogationsFound;
}
/**
 * 
 * @export
 * @interface InterrogationStatus
 */
export interface InterrogationStatus {
    /**
     * The overall status of this interrogation
     * @type {string}
     * @memberof InterrogationStatus
     */
    'state'?: string;
    /**
     * 
     * @type {Array<InterrogationFormStatus>}
     * @memberof InterrogationStatus
     */
    'forms'?: Array<InterrogationFormStatus>;
}
/**
 * 
 * @export
 * @interface KudosTransferred
 */
export interface KudosTransferred {
    /**
     * The amount of Kudos tranferred
     * @type {number}
     * @memberof KudosTransferred
     */
    'transferred'?: number;
}
/**
 * 
 * @export
 * @interface ModelGenerationInputStable
 */
export interface ModelGenerationInputStable {
    /**
     * 
     * @type {string}
     * @memberof ModelGenerationInputStable
     */
    'sampler_name'?: ModelGenerationInputStableSamplerNameEnum;
    /**
     * Obsolete Toggles used in the SD Webui. To be removed. Do not modify unless you know what you\'re doing.
     * @type {Array<number>}
     * @memberof ModelGenerationInputStable
     */
    'toggles'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof ModelGenerationInputStable
     */
    'cfg_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelGenerationInputStable
     */
    'denoising_strength'?: number;
    /**
     * The seed to use to generete this request
     * @type {string}
     * @memberof ModelGenerationInputStable
     */
    'seed'?: string;
    /**
     * The height of the image to generate
     * @type {number}
     * @memberof ModelGenerationInputStable
     */
    'height'?: number;
    /**
     * The width of the image to generate
     * @type {number}
     * @memberof ModelGenerationInputStable
     */
    'width'?: number;
    /**
     * If passed with multiple n, the provided seed will be incremented every time by this value
     * @type {number}
     * @memberof ModelGenerationInputStable
     */
    'seed_variation'?: number;
    /**
     * 
     * @type {Set<string>}
     * @memberof ModelGenerationInputStable
     */
    'post_processing'?: Set<ModelGenerationInputStablePostProcessingEnum>;
    /**
     * Set to True to enable karras noise scheduling tweaks
     * @type {boolean}
     * @memberof ModelGenerationInputStable
     */
    'karras'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModelGenerationInputStable
     */
    'steps'?: number;
    /**
     * The amount of images to generate
     * @type {number}
     * @memberof ModelGenerationInputStable
     */
    'n'?: number;
}

export const ModelGenerationInputStableSamplerNameEnum = {
    KLms: 'k_lms',
    KHeun: 'k_heun',
    KEuler: 'k_euler',
    KEulerA: 'k_euler_a',
    KDpm2: 'k_dpm_2',
    KDpm2A: 'k_dpm_2_a',
    KDpmFast: 'k_dpm_fast',
    KDpmAdaptive: 'k_dpm_adaptive',
    KDpmpp2sA: 'k_dpmpp_2s_a',
    KDpmpp2m: 'k_dpmpp_2m',
    Dpmsolver: 'dpmsolver'
} as const;

export type ModelGenerationInputStableSamplerNameEnum = typeof ModelGenerationInputStableSamplerNameEnum[keyof typeof ModelGenerationInputStableSamplerNameEnum];
export const ModelGenerationInputStablePostProcessingEnum = {
    Gfpgan: 'GFPGAN',
    RealEsrganX4plus: 'RealESRGAN_x4plus',
    CodeFormers: 'CodeFormers'
} as const;

export type ModelGenerationInputStablePostProcessingEnum = typeof ModelGenerationInputStablePostProcessingEnum[keyof typeof ModelGenerationInputStablePostProcessingEnum];

/**
 * 
 * @export
 * @interface ModelGenerationInputStableAllOf
 */
export interface ModelGenerationInputStableAllOf {
    /**
     * 
     * @type {number}
     * @memberof ModelGenerationInputStableAllOf
     */
    'steps'?: number;
    /**
     * The amount of images to generate
     * @type {number}
     * @memberof ModelGenerationInputStableAllOf
     */
    'n'?: number;
}
/**
 * 
 * @export
 * @interface ModelInterrogationFormPayloadStable
 */
export interface ModelInterrogationFormPayloadStable {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ModelInterrogationFormPayloadStable
     */
    '*'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ModelInterrogationFormStable
 */
export interface ModelInterrogationFormStable {
    /**
     * The type of interrogation this is
     * @type {string}
     * @memberof ModelInterrogationFormStable
     */
    'name': ModelInterrogationFormStableNameEnum;
    /**
     * 
     * @type {ModelInterrogationFormPayloadStable}
     * @memberof ModelInterrogationFormStable
     */
    'payload'?: ModelInterrogationFormPayloadStable;
}

export const ModelInterrogationFormStableNameEnum = {
    Caption: 'caption',
    Interrogation: 'interrogation',
    Nsfw: 'nsfw'
} as const;

export type ModelInterrogationFormStableNameEnum = typeof ModelInterrogationFormStableNameEnum[keyof typeof ModelInterrogationFormStableNameEnum];

/**
 * 
 * @export
 * @interface ModelInterrogationInputStable
 */
export interface ModelInterrogationInputStable {
    /**
     * 
     * @type {Array<ModelInterrogationFormStable>}
     * @memberof ModelInterrogationInputStable
     */
    'forms'?: Array<ModelInterrogationFormStable>;
    /**
     * The public URL of the image to interrogate
     * @type {string}
     * @memberof ModelInterrogationInputStable
     */
    'source_image'?: string;
}
/**
 * 
 * @export
 * @interface ModelPayloadRootStable
 */
export interface ModelPayloadRootStable {
    /**
     * 
     * @type {string}
     * @memberof ModelPayloadRootStable
     */
    'sampler_name'?: ModelPayloadRootStableSamplerNameEnum;
    /**
     * Obsolete Toggles used in the SD Webui. To be removed. Do not modify unless you know what you\'re doing.
     * @type {Array<number>}
     * @memberof ModelPayloadRootStable
     */
    'toggles'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof ModelPayloadRootStable
     */
    'cfg_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelPayloadRootStable
     */
    'denoising_strength'?: number;
    /**
     * The seed to use to generete this request
     * @type {string}
     * @memberof ModelPayloadRootStable
     */
    'seed'?: string;
    /**
     * The height of the image to generate
     * @type {number}
     * @memberof ModelPayloadRootStable
     */
    'height'?: number;
    /**
     * The width of the image to generate
     * @type {number}
     * @memberof ModelPayloadRootStable
     */
    'width'?: number;
    /**
     * If passed with multiple n, the provided seed will be incremented every time by this value
     * @type {number}
     * @memberof ModelPayloadRootStable
     */
    'seed_variation'?: number;
    /**
     * 
     * @type {Set<string>}
     * @memberof ModelPayloadRootStable
     */
    'post_processing'?: Set<ModelPayloadRootStablePostProcessingEnum>;
    /**
     * Set to True to enable karras noise scheduling tweaks
     * @type {boolean}
     * @memberof ModelPayloadRootStable
     */
    'karras'?: boolean;
}

export const ModelPayloadRootStableSamplerNameEnum = {
    KLms: 'k_lms',
    KHeun: 'k_heun',
    KEuler: 'k_euler',
    KEulerA: 'k_euler_a',
    KDpm2: 'k_dpm_2',
    KDpm2A: 'k_dpm_2_a',
    KDpmFast: 'k_dpm_fast',
    KDpmAdaptive: 'k_dpm_adaptive',
    KDpmpp2sA: 'k_dpmpp_2s_a',
    KDpmpp2m: 'k_dpmpp_2m',
    Dpmsolver: 'dpmsolver'
} as const;

export type ModelPayloadRootStableSamplerNameEnum = typeof ModelPayloadRootStableSamplerNameEnum[keyof typeof ModelPayloadRootStableSamplerNameEnum];
export const ModelPayloadRootStablePostProcessingEnum = {
    Gfpgan: 'GFPGAN',
    RealEsrganX4plus: 'RealESRGAN_x4plus',
    CodeFormers: 'CodeFormers'
} as const;

export type ModelPayloadRootStablePostProcessingEnum = typeof ModelPayloadRootStablePostProcessingEnum[keyof typeof ModelPayloadRootStablePostProcessingEnum];

/**
 * 
 * @export
 * @interface ModelPayloadStable
 */
export interface ModelPayloadStable {
    /**
     * 
     * @type {string}
     * @memberof ModelPayloadStable
     */
    'sampler_name'?: ModelPayloadStableSamplerNameEnum;
    /**
     * Obsolete Toggles used in the SD Webui. To be removed. Do not modify unless you know what you\'re doing.
     * @type {Array<number>}
     * @memberof ModelPayloadStable
     */
    'toggles'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof ModelPayloadStable
     */
    'cfg_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelPayloadStable
     */
    'denoising_strength'?: number;
    /**
     * The seed to use to generete this request
     * @type {string}
     * @memberof ModelPayloadStable
     */
    'seed'?: string;
    /**
     * The height of the image to generate
     * @type {number}
     * @memberof ModelPayloadStable
     */
    'height'?: number;
    /**
     * The width of the image to generate
     * @type {number}
     * @memberof ModelPayloadStable
     */
    'width'?: number;
    /**
     * If passed with multiple n, the provided seed will be incremented every time by this value
     * @type {number}
     * @memberof ModelPayloadStable
     */
    'seed_variation'?: number;
    /**
     * 
     * @type {Set<string>}
     * @memberof ModelPayloadStable
     */
    'post_processing'?: Set<ModelPayloadStablePostProcessingEnum>;
    /**
     * Set to True to enable karras noise scheduling tweaks
     * @type {boolean}
     * @memberof ModelPayloadStable
     */
    'karras'?: boolean;
    /**
     * The prompt which will be sent to Stable Diffusion to generate an image
     * @type {string}
     * @memberof ModelPayloadStable
     */
    'prompt'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelPayloadStable
     */
    'ddim_steps'?: number;
    /**
     * The amount of images to generate
     * @type {number}
     * @memberof ModelPayloadStable
     */
    'n_iter'?: number;
    /**
     * When true will apply NSFW censoring model on the generation
     * @type {boolean}
     * @memberof ModelPayloadStable
     */
    'use_nsfw_censor'?: boolean;
    /**
     * When true will use embeddings from the concepts library when doing the generation
     * @type {boolean}
     * @memberof ModelPayloadStable
     */
    'use_embeds'?: boolean;
}

export const ModelPayloadStableSamplerNameEnum = {
    KLms: 'k_lms',
    KHeun: 'k_heun',
    KEuler: 'k_euler',
    KEulerA: 'k_euler_a',
    KDpm2: 'k_dpm_2',
    KDpm2A: 'k_dpm_2_a',
    KDpmFast: 'k_dpm_fast',
    KDpmAdaptive: 'k_dpm_adaptive',
    KDpmpp2sA: 'k_dpmpp_2s_a',
    KDpmpp2m: 'k_dpmpp_2m',
    Dpmsolver: 'dpmsolver'
} as const;

export type ModelPayloadStableSamplerNameEnum = typeof ModelPayloadStableSamplerNameEnum[keyof typeof ModelPayloadStableSamplerNameEnum];
export const ModelPayloadStablePostProcessingEnum = {
    Gfpgan: 'GFPGAN',
    RealEsrganX4plus: 'RealESRGAN_x4plus',
    CodeFormers: 'CodeFormers'
} as const;

export type ModelPayloadStablePostProcessingEnum = typeof ModelPayloadStablePostProcessingEnum[keyof typeof ModelPayloadStablePostProcessingEnum];

/**
 * 
 * @export
 * @interface ModelPayloadStableAllOf
 */
export interface ModelPayloadStableAllOf {
    /**
     * The prompt which will be sent to Stable Diffusion to generate an image
     * @type {string}
     * @memberof ModelPayloadStableAllOf
     */
    'prompt'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelPayloadStableAllOf
     */
    'ddim_steps'?: number;
    /**
     * The amount of images to generate
     * @type {number}
     * @memberof ModelPayloadStableAllOf
     */
    'n_iter'?: number;
    /**
     * When true will apply NSFW censoring model on the generation
     * @type {boolean}
     * @memberof ModelPayloadStableAllOf
     */
    'use_nsfw_censor'?: boolean;
    /**
     * When true will use embeddings from the concepts library when doing the generation
     * @type {boolean}
     * @memberof ModelPayloadStableAllOf
     */
    'use_embeds'?: boolean;
}
/**
 * 
 * @export
 * @interface ModifyTeam
 */
export interface ModifyTeam {
    /**
     * The ID of the team
     * @type {string}
     * @memberof ModifyTeam
     */
    'id'?: string;
    /**
     * The Name of the team
     * @type {string}
     * @memberof ModifyTeam
     */
    'name'?: string;
    /**
     * The Info of the team
     * @type {string}
     * @memberof ModifyTeam
     */
    'info'?: string;
}
/**
 * 
 * @export
 * @interface ModifyTeamInput
 */
export interface ModifyTeamInput {
    /**
     * The name of the team. No profanity allowed!
     * @type {string}
     * @memberof ModifyTeamInput
     */
    'name'?: string;
    /**
     * Extra information or comments about this team.
     * @type {string}
     * @memberof ModifyTeamInput
     */
    'info'?: string;
}
/**
 * 
 * @export
 * @interface ModifyUser
 */
export interface ModifyUser {
    /**
     * The new total Kudos this user has after this request
     * @type {number}
     * @memberof ModifyUser
     */
    'new_kudos'?: number;
    /**
     * The request concurrency this user has after this request
     * @type {number}
     * @memberof ModifyUser
     */
    'concurrency'?: number;
    /**
     * Multiplies the amount of kudos lost when generating images.
     * @type {number}
     * @memberof ModifyUser
     */
    'usage_multiplier'?: number;
    /**
     * Whether this user has been invited to join a worker to the horde and how many of them. When 0, this user cannot add (new) workers to the horde.
     * @type {number}
     * @memberof ModifyUser
     */
    'worker_invited'?: number;
    /**
     * The user\'s new moderator status.
     * @type {boolean}
     * @memberof ModifyUser
     */
    'moderator'?: boolean;
    /**
     * The user\'s new public_workers status.
     * @type {boolean}
     * @memberof ModifyUser
     */
    'public_workers'?: boolean;
    /**
     * The user\'s new username.
     * @type {string}
     * @memberof ModifyUser
     */
    'username'?: string;
    /**
     * The user\'s new monthly kudos total
     * @type {number}
     * @memberof ModifyUser
     */
    'monthly_kudos'?: number;
    /**
     * The user\'s new trusted status
     * @type {boolean}
     * @memberof ModifyUser
     */
    'trusted'?: boolean;
    /**
     * The user\'s new suspiciousness rating
     * @type {number}
     * @memberof ModifyUser
     */
    'new_suspicion'?: number;
    /**
     * The new contact details
     * @type {string}
     * @memberof ModifyUser
     */
    'contact'?: string;
}
/**
 * 
 * @export
 * @interface ModifyUserInput
 */
export interface ModifyUserInput {
    /**
     * The amount of kudos to modify (can be negative)
     * @type {number}
     * @memberof ModifyUserInput
     */
    'kudos'?: number;
    /**
     * The amount of concurrent request this user can have
     * @type {number}
     * @memberof ModifyUserInput
     */
    'concurrency'?: number;
    /**
     * The amount by which to multiply the users kudos consumption
     * @type {number}
     * @memberof ModifyUserInput
     */
    'usage_multiplier'?: number;
    /**
     * Set to the amount of workers this user is allowed to join to the horde when in worker invite-only mode.
     * @type {number}
     * @memberof ModifyUserInput
     */
    'worker_invited'?: number;
    /**
     * Set to true to Make this user a horde moderator
     * @type {boolean}
     * @memberof ModifyUserInput
     */
    'moderator'?: boolean;
    /**
     * Set to true to Make this user a display their worker IDs
     * @type {boolean}
     * @memberof ModifyUserInput
     */
    'public_workers'?: boolean;
    /**
     * When specified, will start assigning the user monthly kudos, starting now!
     * @type {number}
     * @memberof ModifyUserInput
     */
    'monthly_kudos'?: number;
    /**
     * When specified, will change the username. No profanity allowed!
     * @type {string}
     * @memberof ModifyUserInput
     */
    'username'?: string;
    /**
     * When set to true,the user and their servers will not be affected by suspicion
     * @type {boolean}
     * @memberof ModifyUserInput
     */
    'trusted'?: boolean;
    /**
     * Set the user\'s suspicion back to 0
     * @type {boolean}
     * @memberof ModifyUserInput
     */
    'reset_suspicion'?: boolean;
    /**
     * Contact details for the horde admins to reach the user in case of emergency. This is only visible to horde moderators.
     * @type {string}
     * @memberof ModifyUserInput
     */
    'contact'?: string;
}
/**
 * 
 * @export
 * @interface ModifyWorker
 */
export interface ModifyWorker {
    /**
     * The new state of the \'maintenance\' var for this worker. When True, this worker will not pick up any new requests.
     * @type {boolean}
     * @memberof ModifyWorker
     */
    'maintenance'?: boolean;
    /**
     * The new state of the \'paused\' var for this worker. When True, this worker will not be given any new requests.
     * @type {boolean}
     * @memberof ModifyWorker
     */
    'paused'?: boolean;
    /**
     * The new state of the \'info\' var for this worker.
     * @type {string}
     * @memberof ModifyWorker
     */
    'info'?: string;
    /**
     * The new name for this this worker.
     * @type {string}
     * @memberof ModifyWorker
     */
    'name'?: string;
    /**
     * The new team of this worker.
     * @type {string}
     * @memberof ModifyWorker
     */
    'team'?: string;
}
/**
 * 
 * @export
 * @interface ModifyWorkerInput
 */
export interface ModifyWorkerInput {
    /**
     * Set to true to put this worker into maintenance.
     * @type {boolean}
     * @memberof ModifyWorkerInput
     */
    'maintenance'?: boolean;
    /**
     * if maintenance is True, you can optionally provide a message to be used instead of the default maintenance message, so that the owner is informed.
     * @type {string}
     * @memberof ModifyWorkerInput
     */
    'maintenance_msg'?: string;
    /**
     * (Mods only) Set to true to pause this worker.
     * @type {boolean}
     * @memberof ModifyWorkerInput
     */
    'paused'?: boolean;
    /**
     * You can optionally provide a server note which will be seen in the server details. No profanity allowed!
     * @type {string}
     * @memberof ModifyWorkerInput
     */
    'info'?: string;
    /**
     * When this is set, it will change the worker\'s name. No profanity allowed!
     * @type {string}
     * @memberof ModifyWorkerInput
     */
    'name'?: string;
    /**
     * The team towards which this worker contributes kudos.  It an empty string (\'\') is passed, it will leave the worker without a team. No profanity allowed!
     * @type {string}
     * @memberof ModifyWorkerInput
     */
    'team'?: string;
}
/**
 * 
 * @export
 * @interface MonthlyKudos
 */
export interface MonthlyKudos {
    /**
     * How much recurring Kudos this user receives monthly.
     * @type {number}
     * @memberof MonthlyKudos
     */
    'amount'?: number;
    /**
     * Last date this user received monthly Kudos.
     * @type {string}
     * @memberof MonthlyKudos
     */
    'last_received'?: string;
}
/**
 * 
 * @export
 * @interface Newspiece
 */
export interface Newspiece {
    /**
     * The date this newspiece was published
     * @type {string}
     * @memberof Newspiece
     */
    'date_published'?: string;
    /**
     * The actual piece of news
     * @type {string}
     * @memberof Newspiece
     */
    'newspiece'?: string;
    /**
     * How critical this piece of news is.
     * @type {string}
     * @memberof Newspiece
     */
    'importance'?: string;
}
/**
 * 
 * @export
 * @interface NoValidInterrogationsFound
 */
export interface NoValidInterrogationsFound {
    /**
     * How many waiting requests were skipped because they demanded a specific worker
     * @type {number}
     * @memberof NoValidInterrogationsFound
     */
    'worker_id'?: number;
    /**
     * How many waiting requests were skipped because they demanded a trusted worker which this worker is not.
     * @type {number}
     * @memberof NoValidInterrogationsFound
     */
    'untrusted'?: number;
    /**
     * How many waiting requests were skipped because they require a higher version of the bridge than this worker is running (upgrade if you see this in your skipped list).
     * @type {number}
     * @memberof NoValidInterrogationsFound
     */
    'bridge_version'?: number;
}
/**
 * 
 * @export
 * @interface NoValidRequestFound
 */
export interface NoValidRequestFound {
    /**
     * How many waiting requests were skipped because they demanded a specific worker
     * @type {number}
     * @memberof NoValidRequestFound
     */
    'worker_id'?: number;
    /**
     * How many waiting requests were skipped because they required higher performance
     * @type {number}
     * @memberof NoValidRequestFound
     */
    'performance'?: number;
    /**
     * How many waiting requests were skipped because they demanded a nsfw generation which this worker does not provide.
     * @type {number}
     * @memberof NoValidRequestFound
     */
    'nsfw'?: number;
    /**
     * How many waiting requests were skipped because they demanded a generation with a word that this worker does not accept.
     * @type {number}
     * @memberof NoValidRequestFound
     */
    'blacklist'?: number;
    /**
     * How many waiting requests were skipped because they demanded a trusted worker which this worker is not.
     * @type {number}
     * @memberof NoValidRequestFound
     */
    'untrusted'?: number;
    /**
     * How many waiting requests were skipped because they demanded a different model than what this worker provides.
     * @type {number}
     * @memberof NoValidRequestFound
     */
    'models'?: number;
    /**
     * How many waiting requests were skipped because they require a higher version of the bridge than this worker is running (upgrade if you see this in your skipped list).
     * @type {number}
     * @memberof NoValidRequestFound
     */
    'bridge_version'?: number;
}
/**
 * 
 * @export
 * @interface NoValidRequestFoundStable
 */
export interface NoValidRequestFoundStable {
    /**
     * How many waiting requests were skipped because they demanded a specific worker
     * @type {number}
     * @memberof NoValidRequestFoundStable
     */
    'worker_id'?: number;
    /**
     * How many waiting requests were skipped because they required higher performance
     * @type {number}
     * @memberof NoValidRequestFoundStable
     */
    'performance'?: number;
    /**
     * How many waiting requests were skipped because they demanded a nsfw generation which this worker does not provide.
     * @type {number}
     * @memberof NoValidRequestFoundStable
     */
    'nsfw'?: number;
    /**
     * How many waiting requests were skipped because they demanded a generation with a word that this worker does not accept.
     * @type {number}
     * @memberof NoValidRequestFoundStable
     */
    'blacklist'?: number;
    /**
     * How many waiting requests were skipped because they demanded a trusted worker which this worker is not.
     * @type {number}
     * @memberof NoValidRequestFoundStable
     */
    'untrusted'?: number;
    /**
     * How many waiting requests were skipped because they demanded a different model than what this worker provides.
     * @type {number}
     * @memberof NoValidRequestFoundStable
     */
    'models'?: number;
    /**
     * How many waiting requests were skipped because they require a higher version of the bridge than this worker is running (upgrade if you see this in your skipped list).
     * @type {number}
     * @memberof NoValidRequestFoundStable
     */
    'bridge_version'?: number;
    /**
     * How many waiting requests were skipped because they demanded a higher size than this worker provides
     * @type {number}
     * @memberof NoValidRequestFoundStable
     */
    'max_pixels'?: number;
    /**
     * How many waiting requests were skipped because they came from an unsafe IP
     * @type {number}
     * @memberof NoValidRequestFoundStable
     */
    'unsafe_ip'?: number;
    /**
     * How many waiting requests were skipped because they requested img2img
     * @type {number}
     * @memberof NoValidRequestFoundStable
     */
    'img2img'?: number;
    /**
     * How many waiting requests were skipped because they requested inpainting/outpainting
     * @type {number}
     * @memberof NoValidRequestFoundStable
     */
    'painting'?: number;
    /**
     * How many waiting requests were skipped because they requested post-processing
     * @type {number}
     * @memberof NoValidRequestFoundStable
     */
    'post-processing'?: number;
    /**
     * How many waiting requests were skipped because the user didn\'t have enough kudos when this worker requires upfront kudos
     * @type {number}
     * @memberof NoValidRequestFoundStable
     */
    'kudos'?: number;
}
/**
 * 
 * @export
 * @interface NoValidRequestFoundStableAllOf
 */
export interface NoValidRequestFoundStableAllOf {
    /**
     * How many waiting requests were skipped because they demanded a higher size than this worker provides
     * @type {number}
     * @memberof NoValidRequestFoundStableAllOf
     */
    'max_pixels'?: number;
    /**
     * How many waiting requests were skipped because they came from an unsafe IP
     * @type {number}
     * @memberof NoValidRequestFoundStableAllOf
     */
    'unsafe_ip'?: number;
    /**
     * How many waiting requests were skipped because they requested img2img
     * @type {number}
     * @memberof NoValidRequestFoundStableAllOf
     */
    'img2img'?: number;
    /**
     * How many waiting requests were skipped because they requested inpainting/outpainting
     * @type {number}
     * @memberof NoValidRequestFoundStableAllOf
     */
    'painting'?: number;
    /**
     * How many waiting requests were skipped because they requested post-processing
     * @type {number}
     * @memberof NoValidRequestFoundStableAllOf
     */
    'post-processing'?: number;
    /**
     * How many waiting requests were skipped because the user didn\'t have enough kudos when this worker requires upfront kudos
     * @type {number}
     * @memberof NoValidRequestFoundStableAllOf
     */
    'kudos'?: number;
}
/**
 * 
 * @export
 * @interface PopInput
 */
export interface PopInput {
    /**
     * The Name of the Worker
     * @type {string}
     * @memberof PopInput
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PopInput
     */
    'priority_usernames'?: Array<string>;
    /**
     * Whether this worker can generate NSFW requests or not.
     * @type {boolean}
     * @memberof PopInput
     */
    'nsfw'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PopInput
     */
    'blacklist'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PopInput
     */
    'models'?: Array<string>;
    /**
     * The version of the bridge used by this worker
     * @type {number}
     * @memberof PopInput
     */
    'bridge_version'?: number;
    /**
     * How many threads this worker is running. This is used to accurately the current power available in the horde
     * @type {number}
     * @memberof PopInput
     */
    'threads'?: number;
}
/**
 * 
 * @export
 * @interface PopInputStable
 */
export interface PopInputStable {
    /**
     * The Name of the Worker
     * @type {string}
     * @memberof PopInputStable
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PopInputStable
     */
    'priority_usernames'?: Array<string>;
    /**
     * Whether this worker can generate NSFW requests or not.
     * @type {boolean}
     * @memberof PopInputStable
     */
    'nsfw'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PopInputStable
     */
    'blacklist'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PopInputStable
     */
    'models'?: Array<string>;
    /**
     * The version of the bridge used by this worker
     * @type {number}
     * @memberof PopInputStable
     */
    'bridge_version'?: number;
    /**
     * How many threads this worker is running. This is used to accurately the current power available in the horde
     * @type {number}
     * @memberof PopInputStable
     */
    'threads'?: number;
    /**
     * The maximum amount of pixels this worker can generate
     * @type {number}
     * @memberof PopInputStable
     */
    'max_pixels'?: number;
    /**
     * If True, this worker will pick up img2img requests
     * @type {boolean}
     * @memberof PopInputStable
     */
    'allow_img2img'?: boolean;
    /**
     * If True, this worker will pick up inpainting/outpainting requests
     * @type {boolean}
     * @memberof PopInputStable
     */
    'allow_painting'?: boolean;
    /**
     * If True, this worker will pick up img2img requests coming from clients with an unsafe IP.
     * @type {boolean}
     * @memberof PopInputStable
     */
    'allow_unsafe_ipaddr'?: boolean;
    /**
     * If True, this worker will pick up requests requesting post-processing.
     * @type {boolean}
     * @memberof PopInputStable
     */
    'allow_post_processing'?: boolean;
    /**
     * If True, then will only pick up requests where the users has the required kudos for them already.
     * @type {boolean}
     * @memberof PopInputStable
     */
    'require_upfront_kudos'?: boolean;
}
/**
 * 
 * @export
 * @interface PopInputStableAllOf
 */
export interface PopInputStableAllOf {
    /**
     * The maximum amount of pixels this worker can generate
     * @type {number}
     * @memberof PopInputStableAllOf
     */
    'max_pixels'?: number;
    /**
     * If True, this worker will pick up img2img requests
     * @type {boolean}
     * @memberof PopInputStableAllOf
     */
    'allow_img2img'?: boolean;
    /**
     * If True, this worker will pick up inpainting/outpainting requests
     * @type {boolean}
     * @memberof PopInputStableAllOf
     */
    'allow_painting'?: boolean;
    /**
     * If True, this worker will pick up img2img requests coming from clients with an unsafe IP.
     * @type {boolean}
     * @memberof PopInputStableAllOf
     */
    'allow_unsafe_ipaddr'?: boolean;
    /**
     * If True, this worker will pick up requests requesting post-processing.
     * @type {boolean}
     * @memberof PopInputStableAllOf
     */
    'allow_post_processing'?: boolean;
    /**
     * If True, then will only pick up requests where the users has the required kudos for them already.
     * @type {boolean}
     * @memberof PopInputStableAllOf
     */
    'require_upfront_kudos'?: boolean;
}
/**
 * 
 * @export
 * @interface PostInterrogateSubmitRequest
 */
export interface PostInterrogateSubmitRequest {
    /**
     * 
     * @type {string}
     * @memberof PostInterrogateSubmitRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostInterrogateSubmitRequest
     */
    'result'?: string;
}
/**
 * 
 * @export
 * @interface PostJobSubmitRequest
 */
export interface PostJobSubmitRequest {
    /**
     * 
     * @type {string}
     * @memberof PostJobSubmitRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostJobSubmitRequest
     */
    'generation'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostJobSubmitRequest
     */
    'seed'?: string;
}
/**
 * 
 * @export
 * @interface PostTransferKudosRequest
 */
export interface PostTransferKudosRequest {
    /**
     * 
     * @type {string}
     * @memberof PostTransferKudosRequest
     */
    'username'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostTransferKudosRequest
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @interface PutHordeModesRequest
 */
export interface PutHordeModesRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PutHordeModesRequest
     */
    'maintenance'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PutHordeModesRequest
     */
    'shutdown'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PutHordeModesRequest
     */
    'invite_only'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PutHordeModesRequest
     */
    'raid'?: boolean;
}
/**
 * 
 * @export
 * @interface RequestAsync
 */
export interface RequestAsync {
    /**
     * The UUID of the request. Use this to retrieve the request status in the future
     * @type {string}
     * @memberof RequestAsync
     */
    'id'?: string;
    /**
     * Any extra information from the horde about this request
     * @type {string}
     * @memberof RequestAsync
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface RequestError
 */
export interface RequestError {
    /**
     * The error message for this status code.
     * @type {string}
     * @memberof RequestError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface RequestInterrogationResponse
 */
export interface RequestInterrogationResponse {
    /**
     * The UUID of the request. Use this to retrieve the request status in the future
     * @type {string}
     * @memberof RequestInterrogationResponse
     */
    'id'?: string;
    /**
     * Any extra information from the horde about this request
     * @type {string}
     * @memberof RequestInterrogationResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface RequestStatusCheck
 */
export interface RequestStatusCheck {
    /**
     * The amount of finished jobs in this request
     * @type {number}
     * @memberof RequestStatusCheck
     */
    'finished'?: number;
    /**
     * The amount of still processing jobs in this request
     * @type {number}
     * @memberof RequestStatusCheck
     */
    'processing'?: number;
    /**
     * The amount of jobs that timed out and had to be restarted or were reported as failed by a worker
     * @type {number}
     * @memberof RequestStatusCheck
     */
    'restarted'?: number;
    /**
     * The amount of jobs waiting to be picked up by a worker
     * @type {number}
     * @memberof RequestStatusCheck
     */
    'waiting'?: number;
    /**
     * True when all jobs in this request are done. Else False.
     * @type {boolean}
     * @memberof RequestStatusCheck
     */
    'done'?: boolean;
    /**
     * True when this request caused an internal server error and could not be completed.
     * @type {boolean}
     * @memberof RequestStatusCheck
     */
    'faulted'?: boolean;
    /**
     * The expected amount to wait (in seconds) to generate all jobs in this request
     * @type {number}
     * @memberof RequestStatusCheck
     */
    'wait_time'?: number;
    /**
     * The position in the requests queue. This position is determined by relative Kudos amounts.
     * @type {number}
     * @memberof RequestStatusCheck
     */
    'queue_position'?: number;
    /**
     * The amount of total Kudos this request has consumed until now.
     * @type {number}
     * @memberof RequestStatusCheck
     */
    'kudos'?: number;
    /**
     * If False, this request will not be able to be completed with the pool of workers currently available
     * @type {boolean}
     * @memberof RequestStatusCheck
     */
    'is_possible'?: boolean;
}
/**
 * 
 * @export
 * @interface RequestStatusStable
 */
export interface RequestStatusStable {
    /**
     * The amount of finished jobs in this request
     * @type {number}
     * @memberof RequestStatusStable
     */
    'finished'?: number;
    /**
     * The amount of still processing jobs in this request
     * @type {number}
     * @memberof RequestStatusStable
     */
    'processing'?: number;
    /**
     * The amount of jobs that timed out and had to be restarted or were reported as failed by a worker
     * @type {number}
     * @memberof RequestStatusStable
     */
    'restarted'?: number;
    /**
     * The amount of jobs waiting to be picked up by a worker
     * @type {number}
     * @memberof RequestStatusStable
     */
    'waiting'?: number;
    /**
     * True when all jobs in this request are done. Else False.
     * @type {boolean}
     * @memberof RequestStatusStable
     */
    'done'?: boolean;
    /**
     * True when this request caused an internal server error and could not be completed.
     * @type {boolean}
     * @memberof RequestStatusStable
     */
    'faulted'?: boolean;
    /**
     * The expected amount to wait (in seconds) to generate all jobs in this request
     * @type {number}
     * @memberof RequestStatusStable
     */
    'wait_time'?: number;
    /**
     * The position in the requests queue. This position is determined by relative Kudos amounts.
     * @type {number}
     * @memberof RequestStatusStable
     */
    'queue_position'?: number;
    /**
     * The amount of total Kudos this request has consumed until now.
     * @type {number}
     * @memberof RequestStatusStable
     */
    'kudos'?: number;
    /**
     * If False, this request will not be able to be completed with the pool of workers currently available
     * @type {boolean}
     * @memberof RequestStatusStable
     */
    'is_possible'?: boolean;
    /**
     * 
     * @type {Array<GenerationStable>}
     * @memberof RequestStatusStable
     */
    'generations'?: Array<GenerationStable>;
}
/**
 * 
 * @export
 * @interface RequestStatusStableAllOf
 */
export interface RequestStatusStableAllOf {
    /**
     * 
     * @type {Array<GenerationStable>}
     * @memberof RequestStatusStableAllOf
     */
    'generations'?: Array<GenerationStable>;
}
/**
 * 
 * @export
 * @interface SimpleResponse
 */
export interface SimpleResponse {
    /**
     * The result of this operation
     * @type {string}
     * @memberof SimpleResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface TeamDetails
 */
export interface TeamDetails {
    /**
     * The Name given to this team.
     * @type {string}
     * @memberof TeamDetails
     */
    'name'?: string;
    /**
     * The UUID of this team.
     * @type {string}
     * @memberof TeamDetails
     */
    'id'?: string;
    /**
     * Extra information or comments about this team provided by its owner.
     * @type {string}
     * @memberof TeamDetails
     */
    'info'?: string;
    /**
     * How many images this team\'s workers have generated.
     * @type {number}
     * @memberof TeamDetails
     */
    'requests_fulfilled'?: number;
    /**
     * How many Kudos the workers in this team have been rewarded while part of this team.
     * @type {number}
     * @memberof TeamDetails
     */
    'kudos'?: number;
    /**
     * The total amount of time workers have stayed online while on this team
     * @type {number}
     * @memberof TeamDetails
     */
    'uptime'?: number;
    /**
     * The alias of the user which created this team.
     * @type {string}
     * @memberof TeamDetails
     */
    'creator'?: string;
    /**
     * How many workers have been dedicated to this team
     * @type {number}
     * @memberof TeamDetails
     */
    'worker_count'?: number;
    /**
     * 
     * @type {Array<WorkerDetailsLite>}
     * @memberof TeamDetails
     */
    'workers'?: Array<WorkerDetailsLite>;
    /**
     * 
     * @type {Array<ActiveModelLite>}
     * @memberof TeamDetails
     */
    'models'?: Array<ActiveModelLite>;
}
/**
 * 
 * @export
 * @interface TeamDetailsAllOf
 */
export interface TeamDetailsAllOf {
    /**
     * Extra information or comments about this team provided by its owner.
     * @type {string}
     * @memberof TeamDetailsAllOf
     */
    'info'?: string;
    /**
     * How many images this team\'s workers have generated.
     * @type {number}
     * @memberof TeamDetailsAllOf
     */
    'requests_fulfilled'?: number;
    /**
     * How many Kudos the workers in this team have been rewarded while part of this team.
     * @type {number}
     * @memberof TeamDetailsAllOf
     */
    'kudos'?: number;
    /**
     * The total amount of time workers have stayed online while on this team
     * @type {number}
     * @memberof TeamDetailsAllOf
     */
    'uptime'?: number;
    /**
     * The alias of the user which created this team.
     * @type {string}
     * @memberof TeamDetailsAllOf
     */
    'creator'?: string;
    /**
     * How many workers have been dedicated to this team
     * @type {number}
     * @memberof TeamDetailsAllOf
     */
    'worker_count'?: number;
    /**
     * 
     * @type {Array<WorkerDetailsLite>}
     * @memberof TeamDetailsAllOf
     */
    'workers'?: Array<WorkerDetailsLite>;
    /**
     * 
     * @type {Array<ActiveModelLite>}
     * @memberof TeamDetailsAllOf
     */
    'models'?: Array<ActiveModelLite>;
}
/**
 * 
 * @export
 * @interface TeamDetailsLite
 */
export interface TeamDetailsLite {
    /**
     * The Name given to this team.
     * @type {string}
     * @memberof TeamDetailsLite
     */
    'name'?: string;
    /**
     * The UUID of this team.
     * @type {string}
     * @memberof TeamDetailsLite
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface TeamDetailsStable
 */
export interface TeamDetailsStable {
    /**
     * The Name given to this team.
     * @type {string}
     * @memberof TeamDetailsStable
     */
    'name'?: string;
    /**
     * The UUID of this team.
     * @type {string}
     * @memberof TeamDetailsStable
     */
    'id'?: string;
    /**
     * Extra information or comments about this team provided by its owner.
     * @type {string}
     * @memberof TeamDetailsStable
     */
    'info'?: string;
    /**
     * How many images this team\'s workers have generated.
     * @type {number}
     * @memberof TeamDetailsStable
     */
    'requests_fulfilled'?: number;
    /**
     * How many Kudos the workers in this team have been rewarded while part of this team.
     * @type {number}
     * @memberof TeamDetailsStable
     */
    'kudos'?: number;
    /**
     * The total amount of time workers have stayed online while on this team
     * @type {number}
     * @memberof TeamDetailsStable
     */
    'uptime'?: number;
    /**
     * The alias of the user which created this team.
     * @type {string}
     * @memberof TeamDetailsStable
     */
    'creator'?: string;
    /**
     * How many workers have been dedicated to this team
     * @type {number}
     * @memberof TeamDetailsStable
     */
    'worker_count'?: number;
    /**
     * 
     * @type {Array<WorkerDetailsLite>}
     * @memberof TeamDetailsStable
     */
    'workers'?: Array<WorkerDetailsLite>;
    /**
     * 
     * @type {Array<ActiveModelLite>}
     * @memberof TeamDetailsStable
     */
    'models'?: Array<ActiveModelLite>;
    /**
     * How many megapixelsteps the workers in this team have been rewarded while part of this team.
     * @type {number}
     * @memberof TeamDetailsStable
     */
    'contributions'?: number;
    /**
     * The average performance of the workers in this team, in megapixelsteps per second.
     * @type {number}
     * @memberof TeamDetailsStable
     */
    'performance'?: number;
    /**
     * The total expected speed of this team when all workers are working in parallel, in megapixelsteps per second.
     * @type {number}
     * @memberof TeamDetailsStable
     */
    'speed'?: number;
}
/**
 * 
 * @export
 * @interface TeamDetailsStableAllOf
 */
export interface TeamDetailsStableAllOf {
    /**
     * How many megapixelsteps the workers in this team have been rewarded while part of this team.
     * @type {number}
     * @memberof TeamDetailsStableAllOf
     */
    'contributions'?: number;
    /**
     * The average performance of the workers in this team, in megapixelsteps per second.
     * @type {number}
     * @memberof TeamDetailsStableAllOf
     */
    'performance'?: number;
    /**
     * The total expected speed of this team when all workers are working in parallel, in megapixelsteps per second.
     * @type {number}
     * @memberof TeamDetailsStableAllOf
     */
    'speed'?: number;
}
/**
 * 
 * @export
 * @interface UsageDetails
 */
export interface UsageDetails {
    /**
     * How many images this user has requested
     * @type {number}
     * @memberof UsageDetails
     */
    'requests'?: number;
}
/**
 * 
 * @export
 * @interface UsageDetailsStable
 */
export interface UsageDetailsStable {
    /**
     * How many images this user has requested
     * @type {number}
     * @memberof UsageDetailsStable
     */
    'requests'?: number;
    /**
     * How many megapixelsteps this user has requested
     * @type {number}
     * @memberof UsageDetailsStable
     */
    'megapixelsteps'?: number;
}
/**
 * 
 * @export
 * @interface UsageDetailsStableAllOf
 */
export interface UsageDetailsStableAllOf {
    /**
     * How many megapixelsteps this user has requested
     * @type {number}
     * @memberof UsageDetailsStableAllOf
     */
    'megapixelsteps'?: number;
}
/**
 * 
 * @export
 * @interface UserDetails
 */
export interface UserDetails {
    /**
     * The user\'s unique Username. It is a combination of their chosen alias plus their ID.
     * @type {string}
     * @memberof UserDetails
     */
    'username'?: string;
    /**
     * The user unique ID. It is always an integer.
     * @type {number}
     * @memberof UserDetails
     */
    'id'?: number;
    /**
     * The amount of Kudos this user has. The amount of Kudos determines the priority when requesting image generations.
     * @type {number}
     * @memberof UserDetails
     */
    'kudos'?: number;
    /**
     * (Privileged) The amount of Evaluating Kudos this untrusted user has from generations and uptime. When this number reaches a prespecified threshold, they automatically become trusted.
     * @type {number}
     * @memberof UserDetails
     */
    'evaluating_kudos'?: number;
    /**
     * How many concurrent generations this user may request.
     * @type {number}
     * @memberof UserDetails
     */
    'concurrency'?: number;
    /**
     * Whether this user has been invited to join a worker to the horde and how many of them. When 0, this user cannot add (new) workers to the horde.
     * @type {number}
     * @memberof UserDetails
     */
    'worker_invited'?: number;
    /**
     * This user is a Horde moderator.
     * @type {boolean}
     * @memberof UserDetails
     */
    'moderator'?: boolean;
    /**
     * 
     * @type {UserKudosDetails}
     * @memberof UserDetails
     */
    'kudos_details'?: UserKudosDetails;
    /**
     * How many workers this user has created (active or inactive)
     * @type {number}
     * @memberof UserDetails
     */
    'worker_count'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserDetails
     */
    'worker_ids'?: Array<string>;
    /**
     * 
     * @type {MonthlyKudos}
     * @memberof UserDetails
     */
    'monthly_kudos'?: MonthlyKudos;
    /**
     * This user is a trusted member of the Horde.
     * @type {boolean}
     * @memberof UserDetails
     */
    'trusted'?: boolean;
    /**
     * (Privileged) How much suspicion this user has accumulated
     * @type {number}
     * @memberof UserDetails
     */
    'suspicious'?: number;
    /**
     * If true, this user has not registered using an oauth service.
     * @type {boolean}
     * @memberof UserDetails
     */
    'pseudonymous'?: boolean;
    /**
     * (Privileged) Contact details for the horde admins to reach the user in case of emergency.
     * @type {string}
     * @memberof UserDetails
     */
    'contact'?: string;
}
/**
 * 
 * @export
 * @interface UserDetailsStable
 */
export interface UserDetailsStable {
    /**
     * The user\'s unique Username. It is a combination of their chosen alias plus their ID.
     * @type {string}
     * @memberof UserDetailsStable
     */
    'username'?: string;
    /**
     * The user unique ID. It is always an integer.
     * @type {number}
     * @memberof UserDetailsStable
     */
    'id'?: number;
    /**
     * The amount of Kudos this user has. The amount of Kudos determines the priority when requesting image generations.
     * @type {number}
     * @memberof UserDetailsStable
     */
    'kudos'?: number;
    /**
     * (Privileged) The amount of Evaluating Kudos this untrusted user has from generations and uptime. When this number reaches a prespecified threshold, they automatically become trusted.
     * @type {number}
     * @memberof UserDetailsStable
     */
    'evaluating_kudos'?: number;
    /**
     * How many concurrent generations this user may request.
     * @type {number}
     * @memberof UserDetailsStable
     */
    'concurrency'?: number;
    /**
     * Whether this user has been invited to join a worker to the horde and how many of them. When 0, this user cannot add (new) workers to the horde.
     * @type {number}
     * @memberof UserDetailsStable
     */
    'worker_invited'?: number;
    /**
     * This user is a Horde moderator.
     * @type {boolean}
     * @memberof UserDetailsStable
     */
    'moderator'?: boolean;
    /**
     * 
     * @type {UserKudosDetails}
     * @memberof UserDetailsStable
     */
    'kudos_details'?: UserKudosDetails;
    /**
     * How many workers this user has created (active or inactive)
     * @type {number}
     * @memberof UserDetailsStable
     */
    'worker_count'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserDetailsStable
     */
    'worker_ids'?: Array<string>;
    /**
     * 
     * @type {MonthlyKudos}
     * @memberof UserDetailsStable
     */
    'monthly_kudos'?: MonthlyKudos;
    /**
     * This user is a trusted member of the Horde.
     * @type {boolean}
     * @memberof UserDetailsStable
     */
    'trusted'?: boolean;
    /**
     * (Privileged) How much suspicion this user has accumulated
     * @type {number}
     * @memberof UserDetailsStable
     */
    'suspicious'?: number;
    /**
     * If true, this user has not registered using an oauth service.
     * @type {boolean}
     * @memberof UserDetailsStable
     */
    'pseudonymous'?: boolean;
    /**
     * (Privileged) Contact details for the horde admins to reach the user in case of emergency.
     * @type {string}
     * @memberof UserDetailsStable
     */
    'contact'?: string;
    /**
     * 
     * @type {UsageDetailsStable}
     * @memberof UserDetailsStable
     */
    'usage'?: UsageDetailsStable;
    /**
     * 
     * @type {ContributionsDetailsStable}
     * @memberof UserDetailsStable
     */
    'contributions'?: ContributionsDetailsStable;
}
/**
 * 
 * @export
 * @interface UserDetailsStableAllOf
 */
export interface UserDetailsStableAllOf {
    /**
     * 
     * @type {UserKudosDetails}
     * @memberof UserDetailsStableAllOf
     */
    'kudos_details'?: UserKudosDetails;
    /**
     * 
     * @type {UsageDetailsStable}
     * @memberof UserDetailsStableAllOf
     */
    'usage'?: UsageDetailsStable;
    /**
     * 
     * @type {ContributionsDetailsStable}
     * @memberof UserDetailsStableAllOf
     */
    'contributions'?: ContributionsDetailsStable;
}
/**
 * 
 * @export
 * @interface UserKudosDetails
 */
export interface UserKudosDetails {
    /**
     * The ammount of Kudos accumulated or used for generating images.
     * @type {number}
     * @memberof UserKudosDetails
     */
    'accumulated'?: number;
    /**
     * The amount of Kudos this user has given to other users.
     * @type {number}
     * @memberof UserKudosDetails
     */
    'gifted'?: number;
    /**
     * The amount of Kudos this user has been given by the Horde admins.
     * @type {number}
     * @memberof UserKudosDetails
     */
    'admin'?: number;
    /**
     * The amount of Kudos this user has been given by other users.
     * @type {number}
     * @memberof UserKudosDetails
     */
    'received'?: number;
    /**
     * The amount of Kudos this user has received from recurring rewards.
     * @type {number}
     * @memberof UserKudosDetails
     */
    'recurring'?: number;
}
/**
 * 
 * @export
 * @interface WorkerDetails
 */
export interface WorkerDetails {
    /**
     * The Name given to this worker.
     * @type {string}
     * @memberof WorkerDetails
     */
    'name'?: string;
    /**
     * The UUID of this worker.
     * @type {string}
     * @memberof WorkerDetails
     */
    'id'?: string;
    /**
     * True if the worker has checked-in the past 5 minutes.
     * @type {boolean}
     * @memberof WorkerDetails
     */
    'online'?: boolean;
    /**
     * How many images this worker has generated.
     * @type {number}
     * @memberof WorkerDetails
     */
    'requests_fulfilled'?: number;
    /**
     * How many Kudos this worker has been rewarded in total.
     * @type {number}
     * @memberof WorkerDetails
     */
    'kudos_rewards'?: number;
    /**
     * 
     * @type {WorkerKudosDetails}
     * @memberof WorkerDetails
     */
    'kudos_details'?: WorkerKudosDetails;
    /**
     * The average performance of this worker in human readable form.
     * @type {string}
     * @memberof WorkerDetails
     */
    'performance'?: string;
    /**
     * How many threads this worker is running.
     * @type {number}
     * @memberof WorkerDetails
     */
    'threads'?: number;
    /**
     * The amount of seconds this worker has been online for this Horde.
     * @type {number}
     * @memberof WorkerDetails
     */
    'uptime'?: number;
    /**
     * When True, this worker will not pick up any new requests
     * @type {boolean}
     * @memberof WorkerDetails
     */
    'maintenance_mode'?: boolean;
    /**
     * (Privileged) When True, this worker not be given any new requests.
     * @type {boolean}
     * @memberof WorkerDetails
     */
    'paused'?: boolean;
    /**
     * Extra information or comments about this worker provided by its owner.
     * @type {string}
     * @memberof WorkerDetails
     */
    'info'?: string;
    /**
     * Whether this worker can generate NSFW requests or not.
     * @type {boolean}
     * @memberof WorkerDetails
     */
    'nsfw'?: boolean;
    /**
     * Privileged or public if the owner has allowed it. The alias of the owner of this worker.
     * @type {string}
     * @memberof WorkerDetails
     */
    'owner'?: string;
    /**
     * The worker is trusted to return valid generations.
     * @type {boolean}
     * @memberof WorkerDetails
     */
    'trusted'?: boolean;
    /**
     * (Privileged) How much suspicion this worker has accumulated
     * @type {number}
     * @memberof WorkerDetails
     */
    'suspicious'?: number;
    /**
     * How many jobs this worker has left uncompleted after it started them.
     * @type {number}
     * @memberof WorkerDetails
     */
    'uncompleted_jobs'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkerDetails
     */
    'models'?: Array<string>;
    /**
     * 
     * @type {TeamDetailsLite}
     * @memberof WorkerDetails
     */
    'team'?: TeamDetailsLite;
    /**
     * (Privileged) Contact details for the horde admins to reach the owner of this worker in emergencies.
     * @type {string}
     * @memberof WorkerDetails
     */
    'contact'?: string;
}
/**
 * 
 * @export
 * @interface WorkerDetailsAllOf
 */
export interface WorkerDetailsAllOf {
    /**
     * How many images this worker has generated.
     * @type {number}
     * @memberof WorkerDetailsAllOf
     */
    'requests_fulfilled'?: number;
    /**
     * How many Kudos this worker has been rewarded in total.
     * @type {number}
     * @memberof WorkerDetailsAllOf
     */
    'kudos_rewards'?: number;
    /**
     * 
     * @type {WorkerKudosDetails}
     * @memberof WorkerDetailsAllOf
     */
    'kudos_details'?: WorkerKudosDetails;
    /**
     * The average performance of this worker in human readable form.
     * @type {string}
     * @memberof WorkerDetailsAllOf
     */
    'performance'?: string;
    /**
     * How many threads this worker is running.
     * @type {number}
     * @memberof WorkerDetailsAllOf
     */
    'threads'?: number;
    /**
     * The amount of seconds this worker has been online for this Horde.
     * @type {number}
     * @memberof WorkerDetailsAllOf
     */
    'uptime'?: number;
    /**
     * When True, this worker will not pick up any new requests
     * @type {boolean}
     * @memberof WorkerDetailsAllOf
     */
    'maintenance_mode'?: boolean;
    /**
     * (Privileged) When True, this worker not be given any new requests.
     * @type {boolean}
     * @memberof WorkerDetailsAllOf
     */
    'paused'?: boolean;
    /**
     * Extra information or comments about this worker provided by its owner.
     * @type {string}
     * @memberof WorkerDetailsAllOf
     */
    'info'?: string;
    /**
     * Whether this worker can generate NSFW requests or not.
     * @type {boolean}
     * @memberof WorkerDetailsAllOf
     */
    'nsfw'?: boolean;
    /**
     * Privileged or public if the owner has allowed it. The alias of the owner of this worker.
     * @type {string}
     * @memberof WorkerDetailsAllOf
     */
    'owner'?: string;
    /**
     * The worker is trusted to return valid generations.
     * @type {boolean}
     * @memberof WorkerDetailsAllOf
     */
    'trusted'?: boolean;
    /**
     * (Privileged) How much suspicion this worker has accumulated
     * @type {number}
     * @memberof WorkerDetailsAllOf
     */
    'suspicious'?: number;
    /**
     * How many jobs this worker has left uncompleted after it started them.
     * @type {number}
     * @memberof WorkerDetailsAllOf
     */
    'uncompleted_jobs'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkerDetailsAllOf
     */
    'models'?: Array<string>;
    /**
     * 
     * @type {TeamDetailsLite}
     * @memberof WorkerDetailsAllOf
     */
    'team'?: TeamDetailsLite;
    /**
     * (Privileged) Contact details for the horde admins to reach the owner of this worker in emergencies.
     * @type {string}
     * @memberof WorkerDetailsAllOf
     */
    'contact'?: string;
}
/**
 * 
 * @export
 * @interface WorkerDetailsLite
 */
export interface WorkerDetailsLite {
    /**
     * The Name given to this worker.
     * @type {string}
     * @memberof WorkerDetailsLite
     */
    'name'?: string;
    /**
     * The UUID of this worker.
     * @type {string}
     * @memberof WorkerDetailsLite
     */
    'id'?: string;
    /**
     * True if the worker has checked-in the past 5 minutes.
     * @type {boolean}
     * @memberof WorkerDetailsLite
     */
    'online'?: boolean;
}
/**
 * 
 * @export
 * @interface WorkerDetailsStable
 */
export interface WorkerDetailsStable {
    /**
     * The Name given to this worker.
     * @type {string}
     * @memberof WorkerDetailsStable
     */
    'name'?: string;
    /**
     * The UUID of this worker.
     * @type {string}
     * @memberof WorkerDetailsStable
     */
    'id'?: string;
    /**
     * True if the worker has checked-in the past 5 minutes.
     * @type {boolean}
     * @memberof WorkerDetailsStable
     */
    'online'?: boolean;
    /**
     * How many images this worker has generated.
     * @type {number}
     * @memberof WorkerDetailsStable
     */
    'requests_fulfilled'?: number;
    /**
     * How many Kudos this worker has been rewarded in total.
     * @type {number}
     * @memberof WorkerDetailsStable
     */
    'kudos_rewards'?: number;
    /**
     * 
     * @type {WorkerKudosDetails}
     * @memberof WorkerDetailsStable
     */
    'kudos_details'?: WorkerKudosDetails;
    /**
     * The average performance of this worker in human readable form.
     * @type {string}
     * @memberof WorkerDetailsStable
     */
    'performance'?: string;
    /**
     * How many threads this worker is running.
     * @type {number}
     * @memberof WorkerDetailsStable
     */
    'threads'?: number;
    /**
     * The amount of seconds this worker has been online for this Horde.
     * @type {number}
     * @memberof WorkerDetailsStable
     */
    'uptime'?: number;
    /**
     * When True, this worker will not pick up any new requests
     * @type {boolean}
     * @memberof WorkerDetailsStable
     */
    'maintenance_mode'?: boolean;
    /**
     * (Privileged) When True, this worker not be given any new requests.
     * @type {boolean}
     * @memberof WorkerDetailsStable
     */
    'paused'?: boolean;
    /**
     * Extra information or comments about this worker provided by its owner.
     * @type {string}
     * @memberof WorkerDetailsStable
     */
    'info'?: string;
    /**
     * Whether this worker can generate NSFW requests or not.
     * @type {boolean}
     * @memberof WorkerDetailsStable
     */
    'nsfw'?: boolean;
    /**
     * Privileged or public if the owner has allowed it. The alias of the owner of this worker.
     * @type {string}
     * @memberof WorkerDetailsStable
     */
    'owner'?: string;
    /**
     * The worker is trusted to return valid generations.
     * @type {boolean}
     * @memberof WorkerDetailsStable
     */
    'trusted'?: boolean;
    /**
     * (Privileged) How much suspicion this worker has accumulated
     * @type {number}
     * @memberof WorkerDetailsStable
     */
    'suspicious'?: number;
    /**
     * How many jobs this worker has left uncompleted after it started them.
     * @type {number}
     * @memberof WorkerDetailsStable
     */
    'uncompleted_jobs'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkerDetailsStable
     */
    'models'?: Array<string>;
    /**
     * 
     * @type {TeamDetailsLite}
     * @memberof WorkerDetailsStable
     */
    'team'?: TeamDetailsLite;
    /**
     * (Privileged) Contact details for the horde admins to reach the owner of this worker in emergencies.
     * @type {string}
     * @memberof WorkerDetailsStable
     */
    'contact'?: string;
    /**
     * The maximum pixels in resolution this worker can generate
     * @type {number}
     * @memberof WorkerDetailsStable
     */
    'max_pixels'?: number;
    /**
     * How many megapixelsteps this worker has generated until now
     * @type {number}
     * @memberof WorkerDetailsStable
     */
    'megapixelsteps_generated'?: number;
    /**
     * If True, this worker supports and allows img2img requests.
     * @type {boolean}
     * @memberof WorkerDetailsStable
     */
    'img2img'?: boolean;
    /**
     * If True, this worker supports and allows inpainting requests.
     * @type {boolean}
     * @memberof WorkerDetailsStable
     */
    'painting'?: boolean;
    /**
     * If True, this worker supports and allows post-processing requests.
     * @type {boolean}
     * @memberof WorkerDetailsStable
     */
    'post-processing'?: boolean;
}
/**
 * 
 * @export
 * @interface WorkerDetailsStableAllOf
 */
export interface WorkerDetailsStableAllOf {
    /**
     * The maximum pixels in resolution this worker can generate
     * @type {number}
     * @memberof WorkerDetailsStableAllOf
     */
    'max_pixels'?: number;
    /**
     * How many megapixelsteps this worker has generated until now
     * @type {number}
     * @memberof WorkerDetailsStableAllOf
     */
    'megapixelsteps_generated'?: number;
    /**
     * If True, this worker supports and allows img2img requests.
     * @type {boolean}
     * @memberof WorkerDetailsStableAllOf
     */
    'img2img'?: boolean;
    /**
     * If True, this worker supports and allows inpainting requests.
     * @type {boolean}
     * @memberof WorkerDetailsStableAllOf
     */
    'painting'?: boolean;
    /**
     * If True, this worker supports and allows post-processing requests.
     * @type {boolean}
     * @memberof WorkerDetailsStableAllOf
     */
    'post-processing'?: boolean;
}
/**
 * 
 * @export
 * @interface WorkerKudosDetails
 */
export interface WorkerKudosDetails {
    /**
     * How much Kudos this worker has received for generating images
     * @type {number}
     * @memberof WorkerKudosDetails
     */
    'generated'?: number;
    /**
     * How much Kudos this worker has received for staying online longer
     * @type {number}
     * @memberof WorkerKudosDetails
     */
    'uptime'?: number;
}

/**
 * V2Api - axios parameter creator
 * @export
 */
export const V2ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This request will include all already generated images in base64 encoded .webp files.
         * @summary Cancel an unfinished request
         * @param {string} id 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsyncStatus: async (id: string, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAsyncStatus', 'id', id)
            const localVarPath = `/v2/generate/status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This request will return all already interrogated image results.
         * @summary Cancel an unfinished interrogation request
         * @param {string} id 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInterrogationStatus: async (id: string, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteInterrogationStatus', 'id', id)
            const localVarPath = `/v2/interrogate/status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only usable by horde moderators
         * @summary Remove an IP from timeout
         * @param {string} apikey A mod API key
         * @param {DeleteTimeoutIPInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperationsIp: async (apikey: string, payload: DeleteTimeoutIPInput, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apikey' is not null or undefined
            assertParamExists('deleteOperationsIp', 'apikey', apikey)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('deleteOperationsIp', 'payload', payload)
            const localVarPath = `/v2/operations/ipaddr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only the team\'s creator or a horde moderator can use this endpoint. This action is unrecoverable!
         * @summary Delete the team entry
         * @param {string} teamId 
         * @param {string} [apikey] The Moderator or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamSingle: async (teamId: string, apikey?: string, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('deleteTeamSingle', 'teamId', teamId)
            const localVarPath = `/v2/teams/{team_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will delete the worker and their statistics. Will not affect the kudos generated by that worker for their owner. Only the worker\'s owner and an admin can use this endpoint. This action is unrecoverable!
         * @summary Delete the worker entry
         * @param {string} workerId 
         * @param {string} [apikey] The Moderator or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkerSingle: async (workerId: string, apikey?: string, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workerId' is not null or undefined
            assertParamExists('deleteWorkerSingle', 'workerId', workerId)
            const localVarPath = `/v2/workers/{worker_id}`
                .replace(`{${"worker_id"}}`, encodeURIComponent(String(workerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this request to check the status of a currently running asynchronous request without consuming bandwidth.
         * @summary Retrieve the status of an Asynchronous generation request without images
         * @param {string} id 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsyncCheck: async (id: string, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAsyncCheck', 'id', id)
            const localVarPath = `/v2/generate/check/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This request will include all already generated images in download URL or base64 encoded .webp files. As such, you are requested to not retrieve this endpoint often. Instead use the /check/ endpoint first This endpoint is limited to 10 request per minute
         * @summary Retrieve the full status of an Asynchronous generation request
         * @param {string} id 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsyncStatus: async (id: string, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAsyncStatus', 'id', id)
            const localVarPath = `/v2/generate/status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This can be used to verify a user exists
         * @summary Lookup user details based on their API key
         * @param {string} [apikey] User API key we\&#39;re looking for
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFindUser: async (apikey?: string, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/find_user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary If this loads, this node is available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeartbeat: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/status/heartbeat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Details about the current performance of this Horde
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHordeLoad: async (xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/status/performance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to quicky determine if this horde is in maintenance, invite_only or raid mode.
         * @summary Horde Maintenance Mode Status
         * @param {string} [apikey] The Admin or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHordeModes: async (apikey?: string, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/status/modes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read the latest happenings on the horde
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHordeNews: async (xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/status/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This request will include all already generated images. As such, you are requested to not retrieve this endpoint often. Instead use the /check/ endpoint first
         * @summary Retrieve the full status of an interrogation request
         * @param {string} id 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterrogationStatus: async (id: string, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInterrogationStatus', 'id', id)
            const localVarPath = `/v2/interrogate/status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of models active currently in this horde
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModels: async (xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/status/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Details of a worker Team
         * @param {string} teamId 
         * @param {string} [apikey] The Moderator or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamSingle: async (teamId: string, apikey?: string, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getTeamSingle', 'teamId', teamId)
            const localVarPath = `/v2/teams/{team_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary A List with the details of all teams
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams: async (xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Details and statistics about a specific user
         * @param {string} userId 
         * @param {string} [apikey] The Admin, Mod or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSingle: async (userId: string, apikey?: string, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserSingle', 'userId', userId)
            const localVarPath = `/v2/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary A List with the details and statistic of all registered users
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Can retrieve the details of a worker even if inactive (A worker is considered inactive if it has not checked in for 5 minutes)
         * @summary Details of a registered worker
         * @param {string} workerId 
         * @param {string} [apikey] The Moderator or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkerSingle: async (workerId: string, apikey?: string, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workerId' is not null or undefined
            assertParamExists('getWorkerSingle', 'workerId', workerId)
            const localVarPath = `/v2/workers/{worker_id}`
                .replace(`{${"worker_id"}}`, encodeURIComponent(String(workerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary A List with the details of all registered and active workers
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkers: async (xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/workers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Team\'s information
         * @param {string} teamId 
         * @param {ModifyTeamInput} payload 
         * @param {string} [apikey] The Moderator or Creator API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeamSingle: async (teamId: string, payload: ModifyTeamInput, apikey?: string, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('patchTeamSingle', 'teamId', teamId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('patchTeamSingle', 'payload', payload)
            const localVarPath = `/v2/teams/{team_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will immediately return with the UUID of the request for generation. This endpoint will always be accepted, even if there are no workers available currently to fulfill this request.  Perhaps some will appear in the next 10 minutes. Asynchronous requests live for 10 minutes before being considered stale and being deleted.
         * @summary Initiate an Asynchronous request to generate images
         * @param {string} apikey The API Key corresponding to a registered user
         * @param {GenerationInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAsyncGenerate: async (apikey: string, payload: GenerationInput, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apikey' is not null or undefined
            assertParamExists('postAsyncGenerate', 'apikey', apikey)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postAsyncGenerate', 'payload', payload)
            const localVarPath = `/v2/generate/async`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will immediately return with the UUID of the request for interrogation. This endpoint will always be accepted, even if there are no workers available currently to fulfill this request.  Perhaps some will appear in the next 20 minutes. Asynchronous requests live for 20 minutes before being considered stale and being deleted.
         * @summary Initiate an Asynchronous request to interrogate an image
         * @param {string} apikey A User API key
         * @param {ModelInterrogationInputStable} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterrogate: async (apikey: string, payload: ModelInterrogationInputStable, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apikey' is not null or undefined
            assertParamExists('postInterrogate', 'apikey', apikey)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postInterrogate', 'payload', payload)
            const localVarPath = `/v2/interrogate/async`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used by registered workers only
         * @summary Check if there are interrogation requests queued for fulfillment
         * @param {string} apikey The API Key corresponding to a registered user
         * @param {InterrogationPopInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterrogatePop: async (apikey: string, payload: InterrogationPopInput, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apikey' is not null or undefined
            assertParamExists('postInterrogatePop', 'apikey', apikey)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postInterrogatePop', 'payload', payload)
            const localVarPath = `/v2/interrogate/pop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used by registered workers only
         * @summary Submit the results of an interrogated image
         * @param {string} apikey The worker\&#39;s owner API key
         * @param {PostInterrogateSubmitRequest} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterrogateSubmit: async (apikey: string, payload: PostInterrogateSubmitRequest, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apikey' is not null or undefined
            assertParamExists('postInterrogateSubmit', 'apikey', apikey)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postInterrogateSubmit', 'payload', payload)
            const localVarPath = `/v2/interrogate/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used by registered workers only
         * @summary Check if there are generation requests queued for fulfillment
         * @param {string} apikey The API Key corresponding to a registered user
         * @param {PopInputStable} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobPop: async (apikey: string, payload: PopInputStable, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apikey' is not null or undefined
            assertParamExists('postJobPop', 'apikey', apikey)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postJobPop', 'payload', payload)
            const localVarPath = `/v2/generate/pop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used by registered workers only
         * @summary Submit a generated image
         * @param {string} apikey The worker\&#39;s owner API key
         * @param {PostJobSubmitRequest} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobSubmit: async (apikey: string, payload: PostJobSubmitRequest, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apikey' is not null or undefined
            assertParamExists('postJobSubmit', 'apikey', apikey)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postJobSubmit', 'payload', payload)
            const localVarPath = `/v2/generate/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiate a Synchronous request to generate images This connection will only terminate when the images have been generated, or an error occured. If you connection is interrupted, you will not have the request UUID, so you cannot retrieve the images asynchronously.
         * @summary THIS ENDPOINT HAS BEEN DECOMMISSIONED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSyncGenerate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/generate/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only trusted users can create new teams.
         * @summary Create a new team
         * @param {string} apikey A User API key
         * @param {CreateTeamInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeams: async (apikey: string, payload: CreateTeamInput, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apikey' is not null or undefined
            assertParamExists('postTeams', 'apikey', apikey)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postTeams', 'payload', payload)
            const localVarPath = `/v2/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer Kudos to another registed user
         * @param {string} apikey The sending user\&#39;s API key
         * @param {PostTransferKudosRequest} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransferKudos: async (apikey: string, payload: PostTransferKudosRequest, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apikey' is not null or undefined
            assertParamExists('postTransferKudos', 'apikey', apikey)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postTransferKudos', 'payload', payload)
            const localVarPath = `/v2/kudos/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for admins to (un)set the horde into maintenance, invite_only or raid modes.
         * @summary Change Horde Modes
         * @param {string} apikey The Admin API key
         * @param {PutHordeModesRequest} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putHordeModes: async (apikey: string, payload: PutHordeModesRequest, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apikey' is not null or undefined
            assertParamExists('putHordeModes', 'apikey', apikey)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('putHordeModes', 'payload', payload)
            const localVarPath = `/v2/status/modes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Endpoint for horde admins to perform operations on users
         * @param {string} userId 
         * @param {string} apikey The Admin API key
         * @param {ModifyUserInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserSingle: async (userId: string, apikey: string, payload: ModifyUserInput, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('putUserSingle', 'userId', userId)
            // verify required parameter 'apikey' is not null or undefined
            assertParamExists('putUserSingle', 'apikey', apikey)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('putUserSingle', 'payload', payload)
            const localVarPath = `/v2/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Maintenance can be set by the owner of the serve or an admin.  When in maintenance, the worker will receive a 503 request when trying to retrieve new requests. Use this to avoid disconnecting your worker in the middle of a generation Paused can be set only by the admins of this Horde. When in paused mode, the worker will not be given any requests to generate.
         * @summary Put the worker into maintenance or pause mode
         * @param {string} workerId 
         * @param {string} apikey The Moderator or Owner API key
         * @param {ModifyWorkerInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWorkerSingle: async (workerId: string, apikey: string, payload: ModifyWorkerInput, xFields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workerId' is not null or undefined
            assertParamExists('putWorkerSingle', 'workerId', workerId)
            // verify required parameter 'apikey' is not null or undefined
            assertParamExists('putWorkerSingle', 'apikey', apikey)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('putWorkerSingle', 'payload', payload)
            const localVarPath = `/v2/workers/{worker_id}`
                .replace(`{${"worker_id"}}`, encodeURIComponent(String(workerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apikey != null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }

            if (xFields != null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V2Api - functional programming interface
 * @export
 */
export const V2ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V2ApiAxiosParamCreator(configuration)
    return {
        /**
         * This request will include all already generated images in base64 encoded .webp files.
         * @summary Cancel an unfinished request
         * @param {string} id 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAsyncStatus(id: string, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestStatusStable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAsyncStatus(id, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will return all already interrogated image results.
         * @summary Cancel an unfinished interrogation request
         * @param {string} id 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInterrogationStatus(id: string, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterrogationStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInterrogationStatus(id, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only usable by horde moderators
         * @summary Remove an IP from timeout
         * @param {string} apikey A mod API key
         * @param {DeleteTimeoutIPInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOperationsIp(apikey: string, payload: DeleteTimeoutIPInput, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOperationsIp(apikey, payload, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only the team\'s creator or a horde moderator can use this endpoint. This action is unrecoverable!
         * @summary Delete the team entry
         * @param {string} teamId 
         * @param {string} [apikey] The Moderator or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeamSingle(teamId: string, apikey?: string, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedTeam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeamSingle(teamId, apikey, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will delete the worker and their statistics. Will not affect the kudos generated by that worker for their owner. Only the worker\'s owner and an admin can use this endpoint. This action is unrecoverable!
         * @summary Delete the worker entry
         * @param {string} workerId 
         * @param {string} [apikey] The Moderator or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkerSingle(workerId: string, apikey?: string, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedWorker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkerSingle(workerId, apikey, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this request to check the status of a currently running asynchronous request without consuming bandwidth.
         * @summary Retrieve the status of an Asynchronous generation request without images
         * @param {string} id 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAsyncCheck(id: string, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestStatusCheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsyncCheck(id, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will include all already generated images in download URL or base64 encoded .webp files. As such, you are requested to not retrieve this endpoint often. Instead use the /check/ endpoint first This endpoint is limited to 10 request per minute
         * @summary Retrieve the full status of an Asynchronous generation request
         * @param {string} id 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAsyncStatus(id: string, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestStatusStable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsyncStatus(id, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This can be used to verify a user exists
         * @summary Lookup user details based on their API key
         * @param {string} [apikey] User API key we\&#39;re looking for
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFindUser(apikey?: string, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetailsStable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFindUser(apikey, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary If this loads, this node is available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHeartbeat(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHeartbeat(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Details about the current performance of this Horde
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHordeLoad(xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HordePerformanceStable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHordeLoad(xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to quicky determine if this horde is in maintenance, invite_only or raid mode.
         * @summary Horde Maintenance Mode Status
         * @param {string} [apikey] The Admin or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHordeModes(apikey?: string, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HordeModes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHordeModes(apikey, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Read the latest happenings on the horde
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHordeNews(xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Newspiece>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHordeNews(xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will include all already generated images. As such, you are requested to not retrieve this endpoint often. Instead use the /check/ endpoint first
         * @summary Retrieve the full status of an interrogation request
         * @param {string} id 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterrogationStatus(id: string, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterrogationStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterrogationStatus(id, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of models active currently in this horde
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModels(xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModels(xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Details of a worker Team
         * @param {string} teamId 
         * @param {string} [apikey] The Moderator or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamSingle(teamId: string, apikey?: string, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDetailsStable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamSingle(teamId, apikey, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary A List with the details of all teams
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeams(xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamDetailsStable>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeams(xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Details and statistics about a specific user
         * @param {string} userId 
         * @param {string} [apikey] The Admin, Mod or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSingle(userId: string, apikey?: string, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetailsStable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSingle(userId, apikey, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary A List with the details and statistic of all registered users
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetailsStable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Can retrieve the details of a worker even if inactive (A worker is considered inactive if it has not checked in for 5 minutes)
         * @summary Details of a registered worker
         * @param {string} workerId 
         * @param {string} [apikey] The Moderator or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkerSingle(workerId: string, apikey?: string, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkerDetailsStable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkerSingle(workerId, apikey, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary A List with the details of all registered and active workers
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkers(xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkerDetailsStable>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkers(xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Team\'s information
         * @param {string} teamId 
         * @param {ModifyTeamInput} payload 
         * @param {string} [apikey] The Moderator or Creator API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchTeamSingle(teamId: string, payload: ModifyTeamInput, apikey?: string, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModifyTeam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchTeamSingle(teamId, payload, apikey, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will immediately return with the UUID of the request for generation. This endpoint will always be accepted, even if there are no workers available currently to fulfill this request.  Perhaps some will appear in the next 10 minutes. Asynchronous requests live for 10 minutes before being considered stale and being deleted.
         * @summary Initiate an Asynchronous request to generate images
         * @param {string} apikey The API Key corresponding to a registered user
         * @param {GenerationInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAsyncGenerate(apikey: string, payload: GenerationInput, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestAsync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAsyncGenerate(apikey, payload, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will immediately return with the UUID of the request for interrogation. This endpoint will always be accepted, even if there are no workers available currently to fulfill this request.  Perhaps some will appear in the next 20 minutes. Asynchronous requests live for 20 minutes before being considered stale and being deleted.
         * @summary Initiate an Asynchronous request to interrogate an image
         * @param {string} apikey A User API key
         * @param {ModelInterrogationInputStable} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInterrogate(apikey: string, payload: ModelInterrogationInputStable, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestInterrogationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInterrogate(apikey, payload, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is used by registered workers only
         * @summary Check if there are interrogation requests queued for fulfillment
         * @param {string} apikey The API Key corresponding to a registered user
         * @param {InterrogationPopInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInterrogatePop(apikey: string, payload: InterrogationPopInput, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterrogationPopPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInterrogatePop(apikey, payload, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is used by registered workers only
         * @summary Submit the results of an interrogated image
         * @param {string} apikey The worker\&#39;s owner API key
         * @param {PostInterrogateSubmitRequest} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInterrogateSubmit(apikey: string, payload: PostInterrogateSubmitRequest, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerationSubmitted>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInterrogateSubmit(apikey, payload, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is used by registered workers only
         * @summary Check if there are generation requests queued for fulfillment
         * @param {string} apikey The API Key corresponding to a registered user
         * @param {PopInputStable} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobPop(apikey: string, payload: PopInputStable, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerationPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobPop(apikey, payload, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is used by registered workers only
         * @summary Submit a generated image
         * @param {string} apikey The worker\&#39;s owner API key
         * @param {PostJobSubmitRequest} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobSubmit(apikey: string, payload: PostJobSubmitRequest, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerationSubmitted>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobSubmit(apikey, payload, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiate a Synchronous request to generate images This connection will only terminate when the images have been generated, or an error occured. If you connection is interrupted, you will not have the request UUID, so you cannot retrieve the images asynchronously.
         * @summary THIS ENDPOINT HAS BEEN DECOMMISSIONED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSyncGenerate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSyncGenerate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only trusted users can create new teams.
         * @summary Create a new team
         * @param {string} apikey A User API key
         * @param {CreateTeamInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTeams(apikey: string, payload: CreateTeamInput, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModifyTeam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTeams(apikey, payload, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Transfer Kudos to another registed user
         * @param {string} apikey The sending user\&#39;s API key
         * @param {PostTransferKudosRequest} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTransferKudos(apikey: string, payload: PostTransferKudosRequest, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KudosTransferred>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTransferKudos(apikey, payload, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for admins to (un)set the horde into maintenance, invite_only or raid modes.
         * @summary Change Horde Modes
         * @param {string} apikey The Admin API key
         * @param {PutHordeModesRequest} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putHordeModes(apikey: string, payload: PutHordeModesRequest, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HordeModes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putHordeModes(apikey, payload, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Endpoint for horde admins to perform operations on users
         * @param {string} userId 
         * @param {string} apikey The Admin API key
         * @param {ModifyUserInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserSingle(userId: string, apikey: string, payload: ModifyUserInput, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModifyUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserSingle(userId, apikey, payload, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Maintenance can be set by the owner of the serve or an admin.  When in maintenance, the worker will receive a 503 request when trying to retrieve new requests. Use this to avoid disconnecting your worker in the middle of a generation Paused can be set only by the admins of this Horde. When in paused mode, the worker will not be given any requests to generate.
         * @summary Put the worker into maintenance or pause mode
         * @param {string} workerId 
         * @param {string} apikey The Moderator or Owner API key
         * @param {ModifyWorkerInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putWorkerSingle(workerId: string, apikey: string, payload: ModifyWorkerInput, xFields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModifyWorker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putWorkerSingle(workerId, apikey, payload, xFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V2Api - factory interface
 * @export
 */
export const V2ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V2ApiFp(configuration)
    return {
        /**
         * This request will include all already generated images in base64 encoded .webp files.
         * @summary Cancel an unfinished request
         * @param {string} id 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsyncStatus(id: string, xFields?: string, options?: any): AxiosPromise<RequestStatusStable> {
            return localVarFp.deleteAsyncStatus(id, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will return all already interrogated image results.
         * @summary Cancel an unfinished interrogation request
         * @param {string} id 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInterrogationStatus(id: string, xFields?: string, options?: any): AxiosPromise<InterrogationStatus> {
            return localVarFp.deleteInterrogationStatus(id, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Only usable by horde moderators
         * @summary Remove an IP from timeout
         * @param {string} apikey A mod API key
         * @param {DeleteTimeoutIPInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperationsIp(apikey: string, payload: DeleteTimeoutIPInput, xFields?: string, options?: any): AxiosPromise<SimpleResponse> {
            return localVarFp.deleteOperationsIp(apikey, payload, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Only the team\'s creator or a horde moderator can use this endpoint. This action is unrecoverable!
         * @summary Delete the team entry
         * @param {string} teamId 
         * @param {string} [apikey] The Moderator or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamSingle(teamId: string, apikey?: string, xFields?: string, options?: any): AxiosPromise<DeletedTeam> {
            return localVarFp.deleteTeamSingle(teamId, apikey, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This will delete the worker and their statistics. Will not affect the kudos generated by that worker for their owner. Only the worker\'s owner and an admin can use this endpoint. This action is unrecoverable!
         * @summary Delete the worker entry
         * @param {string} workerId 
         * @param {string} [apikey] The Moderator or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkerSingle(workerId: string, apikey?: string, xFields?: string, options?: any): AxiosPromise<DeletedWorker> {
            return localVarFp.deleteWorkerSingle(workerId, apikey, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this request to check the status of a currently running asynchronous request without consuming bandwidth.
         * @summary Retrieve the status of an Asynchronous generation request without images
         * @param {string} id 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsyncCheck(id: string, xFields?: string, options?: any): AxiosPromise<RequestStatusCheck> {
            return localVarFp.getAsyncCheck(id, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will include all already generated images in download URL or base64 encoded .webp files. As such, you are requested to not retrieve this endpoint often. Instead use the /check/ endpoint first This endpoint is limited to 10 request per minute
         * @summary Retrieve the full status of an Asynchronous generation request
         * @param {string} id 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsyncStatus(id: string, xFields?: string, options?: any): AxiosPromise<RequestStatusStable> {
            return localVarFp.getAsyncStatus(id, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This can be used to verify a user exists
         * @summary Lookup user details based on their API key
         * @param {string} [apikey] User API key we\&#39;re looking for
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFindUser(apikey?: string, xFields?: string, options?: any): AxiosPromise<UserDetailsStable> {
            return localVarFp.getFindUser(apikey, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary If this loads, this node is available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeartbeat(options?: any): AxiosPromise<void> {
            return localVarFp.getHeartbeat(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Details about the current performance of this Horde
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHordeLoad(xFields?: string, options?: any): AxiosPromise<HordePerformanceStable> {
            return localVarFp.getHordeLoad(xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to quicky determine if this horde is in maintenance, invite_only or raid mode.
         * @summary Horde Maintenance Mode Status
         * @param {string} [apikey] The Admin or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHordeModes(apikey?: string, xFields?: string, options?: any): AxiosPromise<HordeModes> {
            return localVarFp.getHordeModes(apikey, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read the latest happenings on the horde
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHordeNews(xFields?: string, options?: any): AxiosPromise<Array<Newspiece>> {
            return localVarFp.getHordeNews(xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will include all already generated images. As such, you are requested to not retrieve this endpoint often. Instead use the /check/ endpoint first
         * @summary Retrieve the full status of an interrogation request
         * @param {string} id 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterrogationStatus(id: string, xFields?: string, options?: any): AxiosPromise<InterrogationStatus> {
            return localVarFp.getInterrogationStatus(id, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of models active currently in this horde
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModels(xFields?: string, options?: any): AxiosPromise<Array<ActiveModel>> {
            return localVarFp.getModels(xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Details of a worker Team
         * @param {string} teamId 
         * @param {string} [apikey] The Moderator or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamSingle(teamId: string, apikey?: string, xFields?: string, options?: any): AxiosPromise<TeamDetailsStable> {
            return localVarFp.getTeamSingle(teamId, apikey, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary A List with the details of all teams
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(xFields?: string, options?: any): AxiosPromise<Array<TeamDetailsStable>> {
            return localVarFp.getTeams(xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Details and statistics about a specific user
         * @param {string} userId 
         * @param {string} [apikey] The Admin, Mod or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSingle(userId: string, apikey?: string, xFields?: string, options?: any): AxiosPromise<UserDetailsStable> {
            return localVarFp.getUserSingle(userId, apikey, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary A List with the details and statistic of all registered users
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(xFields?: string, options?: any): AxiosPromise<UserDetailsStable> {
            return localVarFp.getUsers(xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Can retrieve the details of a worker even if inactive (A worker is considered inactive if it has not checked in for 5 minutes)
         * @summary Details of a registered worker
         * @param {string} workerId 
         * @param {string} [apikey] The Moderator or Owner API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkerSingle(workerId: string, apikey?: string, xFields?: string, options?: any): AxiosPromise<WorkerDetailsStable> {
            return localVarFp.getWorkerSingle(workerId, apikey, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary A List with the details of all registered and active workers
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkers(xFields?: string, options?: any): AxiosPromise<Array<WorkerDetailsStable>> {
            return localVarFp.getWorkers(xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Team\'s information
         * @param {string} teamId 
         * @param {ModifyTeamInput} payload 
         * @param {string} [apikey] The Moderator or Creator API key
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeamSingle(teamId: string, payload: ModifyTeamInput, apikey?: string, xFields?: string, options?: any): AxiosPromise<ModifyTeam> {
            return localVarFp.patchTeamSingle(teamId, payload, apikey, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will immediately return with the UUID of the request for generation. This endpoint will always be accepted, even if there are no workers available currently to fulfill this request.  Perhaps some will appear in the next 10 minutes. Asynchronous requests live for 10 minutes before being considered stale and being deleted.
         * @summary Initiate an Asynchronous request to generate images
         * @param {string} apikey The API Key corresponding to a registered user
         * @param {GenerationInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAsyncGenerate(apikey: string, payload: GenerationInput, xFields?: string, options?: any): AxiosPromise<RequestAsync> {
            return localVarFp.postAsyncGenerate(apikey, payload, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will immediately return with the UUID of the request for interrogation. This endpoint will always be accepted, even if there are no workers available currently to fulfill this request.  Perhaps some will appear in the next 20 minutes. Asynchronous requests live for 20 minutes before being considered stale and being deleted.
         * @summary Initiate an Asynchronous request to interrogate an image
         * @param {string} apikey A User API key
         * @param {ModelInterrogationInputStable} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterrogate(apikey: string, payload: ModelInterrogationInputStable, xFields?: string, options?: any): AxiosPromise<RequestInterrogationResponse> {
            return localVarFp.postInterrogate(apikey, payload, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used by registered workers only
         * @summary Check if there are interrogation requests queued for fulfillment
         * @param {string} apikey The API Key corresponding to a registered user
         * @param {InterrogationPopInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterrogatePop(apikey: string, payload: InterrogationPopInput, xFields?: string, options?: any): AxiosPromise<InterrogationPopPayload> {
            return localVarFp.postInterrogatePop(apikey, payload, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used by registered workers only
         * @summary Submit the results of an interrogated image
         * @param {string} apikey The worker\&#39;s owner API key
         * @param {PostInterrogateSubmitRequest} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterrogateSubmit(apikey: string, payload: PostInterrogateSubmitRequest, xFields?: string, options?: any): AxiosPromise<GenerationSubmitted> {
            return localVarFp.postInterrogateSubmit(apikey, payload, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used by registered workers only
         * @summary Check if there are generation requests queued for fulfillment
         * @param {string} apikey The API Key corresponding to a registered user
         * @param {PopInputStable} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobPop(apikey: string, payload: PopInputStable, xFields?: string, options?: any): AxiosPromise<GenerationPayload> {
            return localVarFp.postJobPop(apikey, payload, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used by registered workers only
         * @summary Submit a generated image
         * @param {string} apikey The worker\&#39;s owner API key
         * @param {PostJobSubmitRequest} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobSubmit(apikey: string, payload: PostJobSubmitRequest, xFields?: string, options?: any): AxiosPromise<GenerationSubmitted> {
            return localVarFp.postJobSubmit(apikey, payload, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiate a Synchronous request to generate images This connection will only terminate when the images have been generated, or an error occured. If you connection is interrupted, you will not have the request UUID, so you cannot retrieve the images asynchronously.
         * @summary THIS ENDPOINT HAS BEEN DECOMMISSIONED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSyncGenerate(options?: any): AxiosPromise<void> {
            return localVarFp.postSyncGenerate(options).then((request) => request(axios, basePath));
        },
        /**
         * Only trusted users can create new teams.
         * @summary Create a new team
         * @param {string} apikey A User API key
         * @param {CreateTeamInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeams(apikey: string, payload: CreateTeamInput, xFields?: string, options?: any): AxiosPromise<ModifyTeam> {
            return localVarFp.postTeams(apikey, payload, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer Kudos to another registed user
         * @param {string} apikey The sending user\&#39;s API key
         * @param {PostTransferKudosRequest} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransferKudos(apikey: string, payload: PostTransferKudosRequest, xFields?: string, options?: any): AxiosPromise<KudosTransferred> {
            return localVarFp.postTransferKudos(apikey, payload, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for admins to (un)set the horde into maintenance, invite_only or raid modes.
         * @summary Change Horde Modes
         * @param {string} apikey The Admin API key
         * @param {PutHordeModesRequest} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putHordeModes(apikey: string, payload: PutHordeModesRequest, xFields?: string, options?: any): AxiosPromise<HordeModes> {
            return localVarFp.putHordeModes(apikey, payload, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Endpoint for horde admins to perform operations on users
         * @param {string} userId 
         * @param {string} apikey The Admin API key
         * @param {ModifyUserInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserSingle(userId: string, apikey: string, payload: ModifyUserInput, xFields?: string, options?: any): AxiosPromise<ModifyUser> {
            return localVarFp.putUserSingle(userId, apikey, payload, xFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Maintenance can be set by the owner of the serve or an admin.  When in maintenance, the worker will receive a 503 request when trying to retrieve new requests. Use this to avoid disconnecting your worker in the middle of a generation Paused can be set only by the admins of this Horde. When in paused mode, the worker will not be given any requests to generate.
         * @summary Put the worker into maintenance or pause mode
         * @param {string} workerId 
         * @param {string} apikey The Moderator or Owner API key
         * @param {ModifyWorkerInput} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWorkerSingle(workerId: string, apikey: string, payload: ModifyWorkerInput, xFields?: string, options?: any): AxiosPromise<ModifyWorker> {
            return localVarFp.putWorkerSingle(workerId, apikey, payload, xFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * V2Api - object-oriented interface
 * @export
 * @class V2Api
 * @extends {BaseAPI}
 */
export class V2Api extends BaseAPI {
    /**
     * This request will include all already generated images in base64 encoded .webp files.
     * @summary Cancel an unfinished request
     * @param {string} id 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public deleteAsyncStatus(id: string, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).deleteAsyncStatus(id, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will return all already interrogated image results.
     * @summary Cancel an unfinished interrogation request
     * @param {string} id 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public deleteInterrogationStatus(id: string, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).deleteInterrogationStatus(id, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only usable by horde moderators
     * @summary Remove an IP from timeout
     * @param {string} apikey A mod API key
     * @param {DeleteTimeoutIPInput} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public deleteOperationsIp(apikey: string, payload: DeleteTimeoutIPInput, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).deleteOperationsIp(apikey, payload, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only the team\'s creator or a horde moderator can use this endpoint. This action is unrecoverable!
     * @summary Delete the team entry
     * @param {string} teamId 
     * @param {string} [apikey] The Moderator or Owner API key
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public deleteTeamSingle(teamId: string, apikey?: string, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).deleteTeamSingle(teamId, apikey, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will delete the worker and their statistics. Will not affect the kudos generated by that worker for their owner. Only the worker\'s owner and an admin can use this endpoint. This action is unrecoverable!
     * @summary Delete the worker entry
     * @param {string} workerId 
     * @param {string} [apikey] The Moderator or Owner API key
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public deleteWorkerSingle(workerId: string, apikey?: string, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).deleteWorkerSingle(workerId, apikey, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this request to check the status of a currently running asynchronous request without consuming bandwidth.
     * @summary Retrieve the status of an Asynchronous generation request without images
     * @param {string} id 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public getAsyncCheck(id: string, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).getAsyncCheck(id, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will include all already generated images in download URL or base64 encoded .webp files. As such, you are requested to not retrieve this endpoint often. Instead use the /check/ endpoint first This endpoint is limited to 10 request per minute
     * @summary Retrieve the full status of an Asynchronous generation request
     * @param {string} id 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public getAsyncStatus(id: string, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).getAsyncStatus(id, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This can be used to verify a user exists
     * @summary Lookup user details based on their API key
     * @param {string} [apikey] User API key we\&#39;re looking for
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public getFindUser(apikey?: string, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).getFindUser(apikey, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary If this loads, this node is available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public getHeartbeat(options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).getHeartbeat(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Details about the current performance of this Horde
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public getHordeLoad(xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).getHordeLoad(xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to quicky determine if this horde is in maintenance, invite_only or raid mode.
     * @summary Horde Maintenance Mode Status
     * @param {string} [apikey] The Admin or Owner API key
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public getHordeModes(apikey?: string, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).getHordeModes(apikey, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read the latest happenings on the horde
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public getHordeNews(xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).getHordeNews(xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will include all already generated images. As such, you are requested to not retrieve this endpoint often. Instead use the /check/ endpoint first
     * @summary Retrieve the full status of an interrogation request
     * @param {string} id 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public getInterrogationStatus(id: string, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).getInterrogationStatus(id, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of models active currently in this horde
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public getModels(xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).getModels(xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Details of a worker Team
     * @param {string} teamId 
     * @param {string} [apikey] The Moderator or Owner API key
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public getTeamSingle(teamId: string, apikey?: string, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).getTeamSingle(teamId, apikey, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary A List with the details of all teams
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public getTeams(xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).getTeams(xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Details and statistics about a specific user
     * @param {string} userId 
     * @param {string} [apikey] The Admin, Mod or Owner API key
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public getUserSingle(userId: string, apikey?: string, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).getUserSingle(userId, apikey, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary A List with the details and statistic of all registered users
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public getUsers(xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).getUsers(xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Can retrieve the details of a worker even if inactive (A worker is considered inactive if it has not checked in for 5 minutes)
     * @summary Details of a registered worker
     * @param {string} workerId 
     * @param {string} [apikey] The Moderator or Owner API key
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public getWorkerSingle(workerId: string, apikey?: string, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).getWorkerSingle(workerId, apikey, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary A List with the details of all registered and active workers
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public getWorkers(xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).getWorkers(xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Team\'s information
     * @param {string} teamId 
     * @param {ModifyTeamInput} payload 
     * @param {string} [apikey] The Moderator or Creator API key
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public patchTeamSingle(teamId: string, payload: ModifyTeamInput, apikey?: string, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).patchTeamSingle(teamId, payload, apikey, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will immediately return with the UUID of the request for generation. This endpoint will always be accepted, even if there are no workers available currently to fulfill this request.  Perhaps some will appear in the next 10 minutes. Asynchronous requests live for 10 minutes before being considered stale and being deleted.
     * @summary Initiate an Asynchronous request to generate images
     * @param {string} apikey The API Key corresponding to a registered user
     * @param {GenerationInput} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public postAsyncGenerate(apikey: string, payload: GenerationInput, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).postAsyncGenerate(apikey, payload, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will immediately return with the UUID of the request for interrogation. This endpoint will always be accepted, even if there are no workers available currently to fulfill this request.  Perhaps some will appear in the next 20 minutes. Asynchronous requests live for 20 minutes before being considered stale and being deleted.
     * @summary Initiate an Asynchronous request to interrogate an image
     * @param {string} apikey A User API key
     * @param {ModelInterrogationInputStable} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public postInterrogate(apikey: string, payload: ModelInterrogationInputStable, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).postInterrogate(apikey, payload, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used by registered workers only
     * @summary Check if there are interrogation requests queued for fulfillment
     * @param {string} apikey The API Key corresponding to a registered user
     * @param {InterrogationPopInput} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public postInterrogatePop(apikey: string, payload: InterrogationPopInput, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).postInterrogatePop(apikey, payload, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used by registered workers only
     * @summary Submit the results of an interrogated image
     * @param {string} apikey The worker\&#39;s owner API key
     * @param {PostInterrogateSubmitRequest} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public postInterrogateSubmit(apikey: string, payload: PostInterrogateSubmitRequest, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).postInterrogateSubmit(apikey, payload, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used by registered workers only
     * @summary Check if there are generation requests queued for fulfillment
     * @param {string} apikey The API Key corresponding to a registered user
     * @param {PopInputStable} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public postJobPop(apikey: string, payload: PopInputStable, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).postJobPop(apikey, payload, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used by registered workers only
     * @summary Submit a generated image
     * @param {string} apikey The worker\&#39;s owner API key
     * @param {PostJobSubmitRequest} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public postJobSubmit(apikey: string, payload: PostJobSubmitRequest, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).postJobSubmit(apikey, payload, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiate a Synchronous request to generate images This connection will only terminate when the images have been generated, or an error occured. If you connection is interrupted, you will not have the request UUID, so you cannot retrieve the images asynchronously.
     * @summary THIS ENDPOINT HAS BEEN DECOMMISSIONED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public postSyncGenerate(options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).postSyncGenerate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only trusted users can create new teams.
     * @summary Create a new team
     * @param {string} apikey A User API key
     * @param {CreateTeamInput} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public postTeams(apikey: string, payload: CreateTeamInput, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).postTeams(apikey, payload, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer Kudos to another registed user
     * @param {string} apikey The sending user\&#39;s API key
     * @param {PostTransferKudosRequest} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public postTransferKudos(apikey: string, payload: PostTransferKudosRequest, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).postTransferKudos(apikey, payload, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for admins to (un)set the horde into maintenance, invite_only or raid modes.
     * @summary Change Horde Modes
     * @param {string} apikey The Admin API key
     * @param {PutHordeModesRequest} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public putHordeModes(apikey: string, payload: PutHordeModesRequest, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).putHordeModes(apikey, payload, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Endpoint for horde admins to perform operations on users
     * @param {string} userId 
     * @param {string} apikey The Admin API key
     * @param {ModifyUserInput} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public putUserSingle(userId: string, apikey: string, payload: ModifyUserInput, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).putUserSingle(userId, apikey, payload, xFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Maintenance can be set by the owner of the serve or an admin.  When in maintenance, the worker will receive a 503 request when trying to retrieve new requests. Use this to avoid disconnecting your worker in the middle of a generation Paused can be set only by the admins of this Horde. When in paused mode, the worker will not be given any requests to generate.
     * @summary Put the worker into maintenance or pause mode
     * @param {string} workerId 
     * @param {string} apikey The Moderator or Owner API key
     * @param {ModifyWorkerInput} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V2Api
     */
    public putWorkerSingle(workerId: string, apikey: string, payload: ModifyWorkerInput, xFields?: string, options?: AxiosRequestConfig) {
        return V2ApiFp(this.configuration).putWorkerSingle(workerId, apikey, payload, xFields, options).then((request) => request(this.axios, this.basePath));
    }
}


